{"meta":{"title":"inerdstack","subtitle":"the stack of it nerds","description":"start from zero","author":"inerdstack","url":"http://songda1005.cn"},"pages":[],"posts":[{"title":"减肥ING","slug":"减肥ING","date":"2018-03-05T00:36:31.000Z","updated":"2018-03-05T00:40:26.359Z","comments":true,"path":"2018/03/05/减肥ING/","link":"","permalink":"http://songda1005.cn/2018/03/05/减肥ING/","excerpt":"","text":"####2018-3-5 今天是第一天减肥祝我早日成功！！ 早：牛肉三明治","categories":[],"tags":[{"name":"减肥","slug":"减肥","permalink":"http://songda1005.cn/tags/减肥/"}]},{"title":"JavaScritp变量--匈牙利命名法","slug":"JavaScritp变量-匈牙利命名法","date":"2018-02-12T05:47:40.000Z","updated":"2018-02-12T07:01:39.318Z","comments":true,"path":"2018/02/12/JavaScritp变量-匈牙利命名法/","link":"","permalink":"http://songda1005.cn/2018/02/12/JavaScritp变量-匈牙利命名法/","excerpt":"","text":"JavaScript变量–匈牙利命名法 匈牙利命名法语法：变量名＝类型＋对象描述类型指变量的类型对象描述指对象名字全称或名字的一部分，要求有明确含义，命名要容易记忆容易理解。提示: 虽然JavaScript变量表面上没有类型，但是JavaScript内部还是会为变量赋予相应的类型。 提示: 匈牙利命名法是一位微软程序员发明的，多数的C,C++程序都使用此命名法。 JavaScript变量匈牙利命名类型 JavaScript变量起名类型 变量命名前缀 Array 数组 a Float 浮点 l Function 函数 f Integer(int) 整型 n Object 对象 o Regular Expression 正则 r String 字符串 s JavaScript变量名匈牙利命名法示例 var sWebURL=”www.jb51.net”;从变量的名字可以看出s代表字符串WebURL是网址。var nCheckCount=5;从变量的名字可以看出n代表Integer(整型)，CheckCount代表某种数量。var oDiv1=document.getElementById(‘box1’);从变量的名字可以看出o代表Object(对象)。 使用匈牙利命名法非常简单直观，方便判断变量的类型，而且方便程序的阅读与维护。 本文借鉴于：http://www.cnblogs.com/woohblog/archive/2013/01/02/2842457.html","categories":[],"tags":[]},{"title":"HTML5 canvas介绍及应用","slug":"HTML5-canvas介绍及应用","date":"2018-02-12T04:01:08.000Z","updated":"2018-02-12T04:01:51.052Z","comments":true,"path":"2018/02/12/HTML5-canvas介绍及应用/","link":"","permalink":"http://songda1005.cn/2018/02/12/HTML5-canvas介绍及应用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"react-webpack简单配置","slug":"react-webpack简单配置","date":"2018-02-07T14:38:47.000Z","updated":"2018-02-08T08:57:08.357Z","comments":true,"path":"2018/02/07/react-webpack简单配置/","link":"","permalink":"http://songda1005.cn/2018/02/07/react-webpack简单配置/","excerpt":"","text":"首先我们先简单的构建一下项目的目录名字就叫webpack 文件夹，然后我们进到这个文件夹，然后在这里面我们要构建一个从零开始的一个项目结构的目录首先我们现在这个文件夹下面执行一个命令，就是yarn,这个东西和npm差不多，听说你下载的速度比npm快，但是我也没怎么发现，这个东西是facebook推出的，那我来执行这段命令 $ npm i -g yarn 然后安装完之后会有一段提示，说不让你这么安装，说当前的环境有问题，因为是通过npm装的它，如果node出了问题，这个东西就不能用了，但是这个东西没什么问题，我也去查了，证明了这件事，然后我们初始化我们的文件夹，之前是npm init -y,这个也跟它差不多 $ yarn init -y 这时我们的目录会多一个叫package.json的文件 然后我们在根目录创建一个src文件夹，在这个文件夹里创建一个index.js，这个文件是我们的入口文件，然后我们回到根目录来安装我们的webpack $ yarn add webpack —dev —dev这个是开发的依赖 然后我们在全局装一下webpack $ npm i -g webpack 然后我们在根目录创建一个webpack的配置文件叫webpack.config.js,这里面是webpack的主要配置文件,现在我们的目录结构是这样的 然后我们开始配置webpack.config.js 1234567891011// webpack.config.js 第一步const path = require('path') // 引入pathmodule.exports = &#123; // 入口文件 entry:'./src/index.js', // 出口 里面有两个东西 一个是path路径 一个是filename output:&#123; path:path.join(__dirname,'dist'), filename:'build.js' &#125;&#125; 在终端执行 $ webpack 这时我们根目录会生成一个dist文件，里面有一个build.js，这里面是webpack帮你生成的一些内容，这是webpack本身的一些函数，里面的每一行大家都应该知道是什么意思，在这里就不去讲了，现在我们编译的过程已经搞定了，然后我们进入src里面的index.js，这里面我们写一下我们React.js的代码 123import React from 'react';import ReactDOM from 'react-dom';render(&lt;h1&gt;React Hello&lt;/h1&gt;,document.getElementById('root')) 然后执行webpack webpack 会有报错 123456ERROR in ./src/index.jsModule parse failed: Unexpected token (3:7)You may need an appropriate loader to handle this file type.| import React from 'react';| import ReactDOM from 'react-dom';| render(&lt;h1&gt;React Hello&lt;/h1&gt;,document.getElementById('root')) 这时候我们还没有react,和react-dom,它不认识jsx语法然后安装 $ yarn add react react-dom 123import React from 'react';import ReactDOM from 'react-dom';render() //里面先不放 在执行webpack 先在还不识别jsx语法 我们少了一些东西就是babel 123&gt;$ yarn add @babel/preset-react @babel/preset-env @babel/core babel-loader@8.0.0-beta.0 --dev&gt;&gt; 创建.babelrc 文件，加入如下代码: 123&#123; \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"]&#125; 这里是babel的配置这是一个转译的过程，让浏览器能认识 然后我们新建一个index.html文件看看效果 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script src=\"./dist/build.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这个我们的文字就出来了，但是我们是手动引入的&lt;script src=&quot;./dist/build.js&quot;&gt;&lt;/script&gt;这个文件，我们需要让它自动引入，那我们就得在webpack.config.js里面再配置些东西 先下载一个插件,这个插件是自动导入生成的文件 $ yarn add html-webpack-plugin –dev 现在看看我们的配置文件是什么样子 1234567891011121314151617181920212223242526272829303132const path = require('path') // 引入pathconst HTMLWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; // 入口文件 entry:'./src/index.js', // 出口 里面有两个东西 一个是path路径 一个是filename output:&#123; path:path.join(__dirname,'dist'), filename:'build.js' &#125;, module:&#123; // loaders 这是一个数组类型，数组中包含对象，你可以放很多对象，分别来处理各种任务 loaders:[ &#123; test:/\\.js$/, // 用来匹配所有的js文件，这里面写的是一个正则 loader:'babel-loader', exclude:/node_modules/ // 排除 就是除了node_modules 之外 &#125; ] &#125;, plugins:[ // 这个插件是直接把生成的文件直接引用进去，自动引入js 是一个数组类型 // 默认情况下是有参数的 new HTMLWebpackPlugin(&#123; // 模版 template:'./index.html', filename:'index.html', title:'首页', inject:'body' &#125;) ]&#125; 配置完之后我们把之前引入的&lt;script src=&quot;./dist/build.js&quot;&gt;&lt;/script&gt;删除调，在执行命令 $ Webpack 这时我们的dist文件里就有个index.html文件了 最后一步就是相当于我们启动一个服务，首先先执行一下命令，这个命令能让我们更方便的执行 $ yarn add webpack-dev-server —dev 然后在我们的package.json,下加一段话 12345678910111213141516171819202122&#123; \"name\": \"webpack_text\", \"version\": \"1.0.0\", \"main\": \"index.js\", \"license\": \"MIT\", \"scripts\": &#123;// 加的就是这段话 \"start\": \"webpack-dev-server\" &#125;, \"devDependencies\": &#123; \"@babel/core\": \"^7.0.0-beta.39\", \"@babel/preset-env\": \"^7.0.0-beta.39\", \"@babel/preset-react\": \"^7.0.0-beta.39\", \"babel-loader\": \"8.0.0-beta.0\", \"html-webpack-plugin\": \"^2.30.1\", \"webpack\": \"^3.10.0\", \"webpack-dev-server\": \"^2.11.1\" &#125;, \"dependencies\": &#123; \"react\": \"^16.2.0\", \"react-dom\": \"^16.2.0\" &#125;&#125; 然后我们运行命令 $ yarn start 执行完之后，它会告诉我们，我们的项目现在已经运行在http://localhost:8080/，然后我们就直接输入地址http://localhost:8080/，就行了，自动的你对文件进行修改它就会发生变化，实时更新，是不是很好","categories":[],"tags":[]},{"title":"javascript代码规范","slug":"javascript代码规范","date":"2018-02-05T03:25:02.000Z","updated":"2018-02-05T04:00:25.024Z","comments":true,"path":"2018/02/05/javascript代码规范/","link":"","permalink":"http://songda1005.cn/2018/02/05/javascript代码规范/","excerpt":"","text":"运算符、操作符左右两边加空格 语句结尾加分号( ); 函数定义-&gt; function空格，sum空格()，参数列表空格{} 1234// 正确写法function sum () &#123;// 代码 &#125; 箭头函数 12345678// 正确写法let sum = (a，b) =&gt; &#123; return a + b ;&#125;;// 单参数写法let square = number =&gt; &#123; return number * number;&#125;; TabSize定义为2个空格 统一字符串使用双引号&quot;&quot;,多行文本使用模版字符串`` 涉及到判断是否一致，全部使用 ===和!== 代码段中多于行删除 代码段与代码段之间加空行 注释 单行注释，//后加空格 123// 我是注释// 我是注释// 我是注释 多行注释*后注释前，需要加空格 12345/* * 我是多行注释 * 我是多行注释 * 我是多行注释 */ ​","categories":[],"tags":[]},{"title":"meta标签","slug":"meta标签","date":"2018-02-04T12:23:35.000Z","updated":"2018-02-05T02:49:57.450Z","comments":true,"path":"2018/02/04/meta标签/","link":"","permalink":"http://songda1005.cn/2018/02/04/meta标签/","excerpt":"","text":"什么是meta标签根据w3c定义，meta元素是可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。 meta标签位于文档的头部，不包含任何内容。 标签的属性定义了与文档相关联的名称/值对。 简单来说，meta标签是给搜索引擎看的标签，对于seo有着举足轻重的作用。 常用的meta标签descriptionmeta description，被认为是最有用的meta标签，是网站的简介信息。 1&lt;meta name=\"description\" content=\"description of your site\"/&gt; 这个标签在搜索引擎中的占比很高，所以是seo的主要标签，随着各类网站seo的滥用和搜索引擎的算法变更，目前该标签作用逐渐变弱。不过一般推荐还是设置一下，content控制在100个字符以内比较好。 keywordsmeta keywords，慎用的标签。 1&lt;meta name=\"keywords\" content=\"keyword1 keyword2\"/&gt; 曾经是seo重点优化标签，现在由于滥用，基本不再是搜索引擎搜索的标签，而且被发现滥用可能导致搜索引擎把你权重下降，得不偿失。 title严格意义上来说，title不算是meta标签。不过title标签对于搜索引擎的占比很高，所以把它作为meta标签的一类。 1&lt;title&gt;Title Name&lt;/title&gt; 建议控制title在50个字符以内。 charsetmeta charset，默认字符编码。 1&lt;meta charset=\"utf-8\"/&gt; 建议采用这种简写方式，向后兼容。 Compatible兼容标签，针对不同浏览器。 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"/&gt; 我的简单优化(带注释)12345678910111213141516&lt;meta charset=\"utf-8\" /&gt; // 字符编码&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; // 兼容适配&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; // 设备适配&lt;meta name=\"description\" content=\"前端技术博客，关注代码的点点滴滴\" /&gt; // 简介&lt;meta name=\"generator\" content=\"Ghost 0.78\" /&gt; // 生产工具&lt;meta name=\"author\" content=\"宋达\" /&gt; // 作者&lt;meta name=\"robots\" content=\"index,follow\" /&gt; // 搜索优化，下同&lt;meta name=\"google\" content=\"index,follow\" /&gt;&lt;meta name=\"googlebot\" content=\"index,follow\" /&gt;&lt;meta name=\"verify\" content=\"index,follow\" /&gt;&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt; // webapp全屏&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" /&gt; // apple状态栏颜色&lt;meta name=\"format-detection\" content=\"telephone=no, email=no\" /&gt; // 禁止电话邮件自动识别&lt;meta name=\"HandheldFriendly\" content=\"true\" /&gt; // 移动设备优化，针对不支持viewpoint设备&lt;meta name=\"MobileOptimized\" content=\"320\" /&gt; // 微软旧浏览器适配&lt;title&gt;&#123;&#123;meta_title&#125;&#125; - my-的前端博客&lt;/title&gt; // title 本文借鉴于：https://excaliburhan.com/post/seo-and-optimize-meta.html","categories":[],"tags":[]},{"title":"HTML5 data-* 自定义属性","slug":"HTML5-data-自定义属性","date":"2018-02-04T11:58:07.000Z","updated":"2018-02-12T06:53:27.894Z","comments":true,"path":"2018/02/04/HTML5-data-自定义属性/","link":"","permalink":"http://songda1005.cn/2018/02/04/HTML5-data-自定义属性/","excerpt":"","text":"data-* 属性是 HTML 5 的新特性，允许用户在 DOM 中存储自定义信息。 以前，需要存储含有特定含义的信息通常是通过 class 完成的，但这并不是 class 本来的用途。现在，利用 HTML 5，可以为元素添加data-*属性，从而存储自定义信息。其中*是可以自定义的部分。例如： 1&lt;article id=\"tu\" data-category=\"Web Development\" data-author=\"1\"&gt; ... &lt;/article&gt; 通过 JavaScript 访问通过 JavaScript 访问自定义的信息有两种方式：getAttribute()和dataset。 getAttribute 方法这就是经典的取得一个元素属性的方式，和以前一样。 1document.getElementById('tu').getAttribute('data-category');// \"Web Development\" dataset 方法这是 HTML 5 新增的方法，可以更方便的读取所有的 data 信息。 1234var article = document.getElementById('tu');var data = article.dataset;alert(data.category); // \"Web Development\"alert(data.author); // 1 通过 jQuery 访问jQuery 也提供了专门的data方法来访问这些信息： 1$(\"#tu\").data('category'); // \"Web Development\" 通过 CSS 访问使用 attr123article::before &#123; content: attr(data-category);&#125; 使用属性选择器123article[data-author='1'] &#123; border-width: 1px;&#125; 修改信息在引入 jQuery 之前，使用 JavaScript 修改自定义信息也非常容易，两种方式都可以： 123var a = document.getElementById('tu');a.dataset.category = \"Uncategorized\";a.setAttribute(\"data-category\", \"Uncategorized\"); 然而如果你用 jQuery 的data方法进行修改： 1$(\"#tu\").data(\"category\", \"Uncategorized\"); 会发现 HTML 代码并没有改动，同时使用dataset等标准 JavaScript 读出来的数据也是修改之前的数据。类似，如果先用 jQuery 读取一次，然后再用标准 JavaScript 修改，再用 jQuery 读取第二次，则发现读取的数据仍是修改之前的数据。可是如果没有经过 jQuery 读取直接用标准 JavaScript 修改，这时再用 jQuery 读取，读到的就是新数据了。 这是怎么回事儿？ jQuery 的文档对此有所说明： The data- attributes are pulled in the first time the data property is accessed and then are no longer accessed or mutated (all data values are then stored internally in jQuery). 原来，标准 JavaScript 直接对 DOM 进行读写（和我们设想的一致），但是 jQuery 不同。jQuery 的内部也维护着一份这些 data 数据。当第一次使用 jQuery 读取时，数据被从 DOM 读到jQuery.cache保存起来，以后使用 jQuery 修改时，修改的是内部维护的这个数据，同时再次读取也会从 jQuery 内部而非 DOM 读取数据。 因此，最好的办法是，要么一直用标准 JavaScript，要么一直用 jQuery。不要两者混用就好了。jQuery 如此设计的初衷就是为了减少 DOM 读写从而提高性能。 总结一个最大的好处是我们可以把所有自定义属性在dataset对象中统一管理，遍历啊神马的都哦很方便，而不至于零零散散了，所以用用还是不错的。 浏览器兼容性比较不好的消息就是data-*的浏览器兼容性情况十分不乐观 Chrome 8+ Firefox 6.0+ Opera 11.10+ Safari 6+","categories":[],"tags":[]},{"title":"html和xhtml和xml的区别","slug":"html和xhtml和xml的区别","date":"2018-01-31T01:23:57.000Z","updated":"2018-01-31T04:01:59.123Z","comments":true,"path":"2018/01/31/html和xhtml和xml的区别/","link":"","permalink":"http://songda1005.cn/2018/01/31/html和xhtml和xml的区别/","excerpt":"","text":"1、html即是超文本标记语言（Hyper Text Markup Language），是最早写网页的语言，但是由于时间早，规范不是很好，大小写混写且编码不规范； 2、xhtml即是升级版的html（Extensible Hyper Text Markup Language），对html进行了规范，编码更加严谨纯洁，也是一种过渡语言，html向xml过渡的语言； 3、xml即时可扩展标记语言（Extensible Markup Language），是一种跨平台语言，编码更自由，可以自由创建标签。 4、网页编码从html&gt;&gt;xhtml&gt;&gt;xml这个过程发展。 html和xhtml和xml的区别可以参考这个网页：http://www.dreamdu.com/xhtml/html_xhtml/ 1、xhtml对比与html，xhtml文档具有良好完整的排版，体现在两方面：a、元素必须要有结束标签；b、元素必须嵌套； 2、对于html的元素和属性，xhtml必须小写，因为xml是严格区分大小写的，和是不同的标签； 3、xhtml的属性值必须在引号之中； 4、xhtml不支持属性最小化，什么是属性最小化了？ 1234567正确:非最小化属性(unminimized attributes) &lt;input checked=\"checked\"&gt;不正确:最小化属性(minimized attributes) &lt;input checked&gt; 5、 在xhtml中，name属性是不赞成使用的，在以后的版本中将被删除。 总结：再说说为什么网页编码要从html&gt;&gt;xhtml&gt;&gt;xml这么发展？话说早起的网页使用html语言编写的，但是它拥有三个严重的缺点： 1、编码不规范，结构混乱臃肿，需要智能的终端才能很好的显示； 2、表现和结构混乱，不利于开发和维护； 3、不能使用更多的网络设备，比如手机、PDA等; 因此HTML需要发展才能解决这个问题，于是W3C又制定了XHTML，XHTML是HTML向XML 过度的一个桥梁。而xml是web发展的趋势。 本文借鉴于:http://www.cnblogs.com/fredshare/archive/2011/11/10/2244308.html","categories":[],"tags":[]},{"title":"React中state和props分别是什么？","slug":"React中state和props分别是什么？","date":"2018-01-30T12:43:59.000Z","updated":"2018-01-31T00:50:18.621Z","comments":true,"path":"2018/01/30/React中state和props分别是什么？/","link":"","permalink":"http://songda1005.cn/2018/01/30/React中state和props分别是什么？/","excerpt":"","text":"整理一下React中关于state和props的知识点。 在任何应用中，数据都是必不可少的。我们需要直接的改变页面上一块的区域来使得视图的刷新，或者间接地改变其他地方的数据。React的数据是自顶向下单向流动的，即从父组件到子组件中，组件的数据存储在props和state中，这两个属性有啥子区别呢？ propsReact的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件。 组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是props，所以可以把props理解为从外部传入组件内部的数据。由于React是单向数据流，所以props基本上也就是从服父级组件向子组件传递的数据。 用法假设我们现在需要实现一个列表，根据React组件化思想，我们可以把列表中的行当做一个组件，也就是有这样两个组件：&lt;ItemList/&gt;和&lt;Item/&gt;。 先看看&lt;ItemList/&gt; 123456789import Item from &quot;./item&quot;;export default class ItemList extends React.Component&#123; const itemList = data.map(item =&gt; &lt;Item item=item /&gt;); render()&#123; return ( &#123;itemList&#125; ) &#125;&#125; 列表的数据我们就暂时先假设是放在一个data变量中，然后通过map函数返回一个每一项都是&lt;Item item=&#39;数据&#39;/&gt;的数组，也就是说这里其实包含了data.length个&lt;Item/&gt;组件，数据通过在组件上自定义一个参数传递。当然，这里想传递几个自定义参数都可以。 在&lt;Item /&gt;中是这样的： 1234567export default class Item extends React.Component&#123; render()&#123; return ( &lt;li&gt;&#123;this.props.item&#125;&lt;/li&gt; ) &#125;&#125; 在render函数中可以看出，组件内部是使用this.props来获取传递到该组件的所有数据，它是一个对象，包含了所有你对这个组件的配置，现在只包含了一个item属性，所以通过this.props.item来获取即可。 只读性props经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的props是只读的，不可改变的。如果props在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的props传入组件中。 默认参数在组件中，我们最好为props中的参数设置一个defaultProps，并且制定它的类型。比如，这样： 1234567Item.defaultProps = &#123; item: 'Hello Props',&#125;;Item.propTypes = &#123; item: PropTypes.string,&#125;; 关于propTypes，可以声明为以下几种类型： 1234567optionalArray: PropTypes.array,optionalBool: PropTypes.bool,optionalFunc: PropTypes.func,optionalNumber: PropTypes.number,optionalObject: PropTypes.object,optionalString: PropTypes.string,optionalSymbol: PropTypes.symbol, 注意，bool和func是简写。 这些知识基础数据类型，还有一些复杂的，附上链接：https://doc.react-china.org/ 总结props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。 statestate是什么呢？ State is similar to props, but it is private and fully controlled by the component. 一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是props，而数据状态就是state。 用法12345678910111213export default class ItemList extends React.Component&#123; constructor()&#123; super(); this.state = &#123; itemList:&apos;一些数据&apos;, &#125; &#125; render()&#123; return ( &#123;this.state.itemList&#125; ) &#125;&#125; 首先，在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。 setStatestate不同于props的一点是，state是可以被改变的。不过，不可以直接通过this.state=的方式来修改，而需要通过this.setState()方法来修改state。 比如，我们经常会通过异步操作来获取数据，我们需要在didMount阶段来执行异步操作： 1234567componentDidMount()&#123; fetch(&apos;url&apos;) .then(response =&gt; response.json()) .then((data) =&gt; &#123; this.setState(&#123;itemList:item&#125;); &#125;&#125; 当数据获取完成后，通过this.setState来修改数据状态。 当我们调用this.setState方法时，React会更新组件的数据状态state，并且重新调用render方法，也就是会对组件进行重新渲染。 注意：通过this.state=来初始化state，使用this.setState来修改state，constructor是唯一能够初始化的地方。 123456789101112export default class ItemList extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name:&apos;axuebin&apos;, age:25, &#125; &#125; componentDidMount()&#123; this.setState(&#123;age:18&#125;) &#125;&#125; 在执行完setState之后的state应该是{name:&#39;axuebin&#39;,age:18}。 setState还可以接受第二个参数，它是一个函数，会在setState调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成： 123this.setState(&#123; name:&apos;xb&apos;&#125;,()=&gt;console.log(&apos;setState finished&apos;)) 总结state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。 区别 state是组件自己管理数据，控制自己的状态，可变； props是外部传入的数据参数，不可变; 没有state的叫做无状态组件，有state的叫做有状态组件 多用props，少用state。也就是多写无状态组件。 本文借鉴于：https://segmentfault.com/a/1190000011184076","categories":[],"tags":[]},{"title":"React中元素与组件的区别,和组件有几种类型","slug":"React中元素与组件的区别","date":"2018-01-30T11:42:53.000Z","updated":"2018-01-30T12:41:19.834Z","comments":true,"path":"2018/01/30/React中元素与组件的区别/","link":"","permalink":"http://songda1005.cn/2018/01/30/React中元素与组件的区别/","excerpt":"","text":"在初学 React 的时候，分不清 React 组件和 React 元素，着实踩了一些坑。搞清楚 React 中什么是组件，什么是元素，既可以理清楚概念，也可以让你避免一些不必要的错误。 React 元素React 元素（React element），它是 React 中最小基本单位，我们可以使用 JSX 语法轻松地创建一个 React 元素: 1const element = &lt;div className='element'&gt;I'm element&lt;/div&gt; React 元素不是真实的 DOM 元素，它仅仅是 js 的普通对象（plain objects），所以也没办法直接调用 DOM 原生的 API。上面的 JSX 转译后的对象大概是这样的： 1234567891011&#123; _context: Object, _owner: null, key: null, props: &#123; className: 'element'， children: 'I‘m element' &#125;, ref: null, type: \"div\"&#125; 只有在这个元素渲染被完成后，才能通过选择器的方式获取它对应的 DOM 元素。不过，按照 React 有限状态机的设计思想，应该使用状态和属性来表述组件，要尽量避免 DOM 操作，即便要进行 DOM 操作，也应该使用 React 提供的接口ref和getDOMNode()。一般使用 React 提供的接口就足以应付需要 DOM 操作的场景了，因此像 jQuery 强大的选择器在 React 中几乎没有用武之地了。 除了使用 JSX 语法，我们还可以使用 React.createElement() 和 React.cloneElement() 来构建 React 元素。 React.createElement()JSX 语法就是用React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。 12345React.createElement( type, [props], [...children]) React.cloneElement()React.cloneElement()与React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而就的子元素奖杯替换。 12345React.cloneElement( element, [props], [...children]) React 组件React 中有三种构建组件的方式。React.createClass()、ES6 class和无状态函数。 React.createClass()React.createClass()是三种方式中最早，兼容性最好的方法。在0.14版本前官方指定的组件写法。 12345var Greeting = React.createClass(&#123; render : function()&#123; return &lt;h1&gt;Hello,&#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125;); ES6 classES6 class是目前官方推荐的使用方式，它使用了ES6标准语法来构建，但它的实现仍是调用React.createClass()来实现了，ES6 class的生命周期和自动绑定方式与React.createClass()略有不同。 12345class Greeting extends React.Component&#123; render:function()&#123; return &lt;h1&gt;Hello,&#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125; 无状态函数无状态函数是使用函数构建的无状态组件，无状态组件传入props和context两个参数，它没有state，除了render()，没有其它生命周期方法。 123function Greeting (props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; React.createClass()和ES6 class构建的组件的数据结构是类，无状态组件数据结构是函数，它们在 React 被视为是一样的。 元素与组件的区别元素是一个纯的JSON对象，用于描述你想通过DOM节点或者其他组件在荧屏上展示的内容。元素可以在他们的参数里面包含其他元素。创建一个React元素代价非常小。一个元素一旦被创建，将不可更改。 一个组件可以用几种不同的方式去声明。可以是一个带有render()方法的类。作为另外一种选择，在简单的情况下，组件可以被定义为一个函数。在两种方式下，组件都是被传入的参数作为输入内容，以返回的元素作为输出内容。 如果有一个组件被调用，传入了一些参数作为输入，那是因为有一某个父组件返回了一个带有这个组件的type以及这些参数(到React上)。这就是为什么大家都认为参数流动方式只有一种：从父组件到子组件。 实例就是你在组件上调用this时候得到的东西，它对本地状态存储以及对响应生命周期事件非常有用。 函数组件根本没有实例，类组件拥有实例，但是你从来都不需要去直接创建一个组件实例——React会帮你管理好它。 最后，想要创建元素，使用React.createElement(),JSX或者一个元素工厂工具。不要在实际代码上把元素写成纯JSON对象——仅需要知道他们在React机制下面以纯JSON对象存在就好。 本文借鉴于https://segmentfault.com/a/1190000008587988","categories":[],"tags":[]},{"title":"EJS模版","slug":"EJS模版","date":"2018-01-30T00:42:00.000Z","updated":"2018-01-30T11:36:33.277Z","comments":true,"path":"2018/01/30/EJS模版/","link":"","permalink":"http://songda1005.cn/2018/01/30/EJS模版/","excerpt":"","text":"一、EJS模版概念E”是“有效的，EJS是一个简单高效的模版语言，通过数据和模版，可以让您使用普通的JavaScript生成HTML标记","categories":[],"tags":[]},{"title":"grunt的安装与介绍","slug":"grunt的安装与介绍","date":"2018-01-26T06:12:29.000Z","updated":"2018-01-26T06:27:23.969Z","comments":true,"path":"2018/01/26/grunt的安装与介绍/","link":"","permalink":"http://songda1005.cn/2018/01/26/grunt的安装与介绍/","excerpt":"","text":"Grunt安装及使用介绍Grunt都能做什么，自动化，减少像压缩，编译，单元测试，代码效验，打包，管理，优化，多余的东西干掉，这些重复且无业务关联的工作，我们做的越少，就可以留出更多的精力，来专注与我们的业务代码，那为什么我们选择grunt呢，是因为grunt的生态实在是在强大了，只要你能想到的任务，基本上都可以找到grunt的相关的自动化插件，并且grunt的生态一直在持续增长，我们不能给grunt全世界，但是grunt的全世界都给了我们 首先我们先创建一个文件夹名字叫grunt-test 官方站点：http://gruntjs.com/ 然后进入到这个文件夹，在这个文件夹中执行 npm init 然后会提示你是否会创建这一个文件，然后会让我们输入一些东西，比如，版本啊，描述啊，作者啊，关键词啊，等等，我们就默认就行了，最后我们目录下就会生成一个package.json的文件 1234567891011&#123; \"name\": \"grunt-test\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\"&#125; 这样就生成了一个package.json的文件，现在有这个文件了，我们需要在安装执行grunt需要的命令行，就是 npm i -g grunt-cli 注意Mac OS linux 命令前面需要加sudo的语句 然后我们执行一段命令,把真正的grunt安装到我们的项目里面来 $ npm i grunt –save-dev 安装完之后你会发现你项目的目录里会多了一个文件，叫node_modules的文件,里面有很多第三方的库，来支持grunt的运转，然后回到你的package.json,文件里会发现多了点东西 1234567891011121314&#123; \"name\": \"grunt-test\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"grunt\": \"^1.0.1\" &#125;&#125; 多了依赖，就是我们项目用的’grunt’:’^1.0.1’,然后我们在执行grunt $ grunt 不能找到你的Gruntfile Fatal error: Unable to find Gruntfile. 又报错了，说找不到你的Gruntfile文件，Gruntfile文件是什么呢，就是grunt写任务的文件夹，grunt所有的配置都在这个文件里面写，那我们就在项目的根目录创建一个Gruntfile.js文件，创建完之后现在项目的结构是这样的 12345|--grunt-test|--|--node_modules|--|--Gruntfile.js|--|--package.json|--|--package-lock.json 到现在为止我们的grunt就算是安装完了，然后在执行命令 $ grunt 会提示这一句话 123Warning: Task \"default\" not found. Use --force to continue.Aborted due to warnings. 说没有找到”default”的Task,那么怎么实现Task的执行任务呢 首先我们今天就来讲讲js文件压缩，和css文件合并压缩，先准备一个js文件，和css文件，里面有一个你需要压缩的js文件，和css文件，在准备一个空文件夹名字叫做dist文件夹，这个文件夹是用来装你压缩过的文件，让我们看看现在的目录结构是什么样子的 现在我们开始配置我们Gruntfile文件里的内容了，内容是这样的: 123456789101112131415161718192021222324252627282930313233//这个约定了Grunt所有插件在这里配置。 module.exports = function (grunt) &#123;//这是Node.js的典型写法，使用exports公开API grunt.initConfig(&#123; //定义各种模块的参数，每一个成员项对应一个同名模块,项目配置以及任务配置。 pkg:grunt.file.readJSON('package.json'),//获取依赖关系提供你需要的插件的版本和名称 uglify:&#123;//压缩js代码 options: &#123;//这里是uglify任务的配置信息 banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(\"yyyy-mm-dd\") %&gt; */\\n' &#125;, build:&#123; //源文件 files: &#123; 'dist/index.min.js':'js/index.js' &#125; &#125; &#125;, cssmin:&#123;//Css压缩合并 options:&#123; // keepSpecialComments:0 &#125;, compress:&#123; files:&#123; 'dist/default.min.css':[ 'css/saibaiwei.css', 'css/saibaiwei1.css' ] &#125; &#125; &#125; &#125;); grunt.loadNpmTasks('grunt-contrib-uglify');//告诉grunt我们使用的模块 grunt.loadNpmTasks('grunt-contrib-cssmin'); grunt.registerTask('yasuo',['uglify','cssmin'])//定义具体的任务。 // 第一个参数为任务名，第二个参数是一个数组， 表示该任务需要依次使用的模块。 &#125;; 好了朋友们现在配置文件已经写好了，那我们来执行任务吧，首先我们应该安装js压缩，还有css压缩合并需要的插件 js压缩插件 $ npm i grunt-contrib-uglify css压缩合并插件 $ npm i grunt-contrib-cssmin 安装完之后我们就可以执行了，我们需要用grunt命令来执行 grunt.registerTask(&#39;yasuo&#39;,[&#39;uglify&#39;,&#39;cssmin&#39;])里的第一个参数 $ grunt yasuo 命令执行之后你的dist文件里会多出两个压缩的文件，让我们来看看 总结：grunt是最早的，打包工工具，现在有很多打包工具的，比如gulp,webpack，这些都是前端是实用的打包工具，但是随着这些打包工具的出现，grunt也大不如以前了，grunt相当于打包的鼻祖了 1.其实grunt配置很简单，Gruntfile文件是js格式的，比较贴近前端的知识2.Grunt还有很多插件等着我们去使用3.每个人的具体需求不一样，可以按自己的习惯合理配置，组合成最适合自己项目的自动化工作流。","categories":[],"tags":[]},{"title":"HTML标准模式，和怪异模式","slug":"HTML标准模式，和怪异模式","date":"2018-01-15T12:49:20.000Z","updated":"2018-01-15T13:13:02.731Z","comments":true,"path":"2018/01/15/HTML标准模式，和怪异模式/","link":"","permalink":"http://songda1005.cn/2018/01/15/HTML标准模式，和怪异模式/","excerpt":"","text":"一、什么是标准模式和怪异模式在实现html和css标准化之前，各个浏览器对html和css的解析各有不同，甚至是同一个浏览器的不同版本渲染方式也不同（比如IE6和IE7）。在W3C制定标准之后，浏览器既要按照标准去实现HTML和CSS的支持，又要保证能够兼容以前的非标准的旧网页，于是就有了现在所说的标准模式（严格模式）和兼容模式（怪异模式）。 二、浏览器如何确定渲染模式呢在编写HTML文档时，一般都会在文档的开头，html标签之前声明文档类型：DOCTYPE，当浏览器在解析html文档时，若遇到正确的文档声明，则启用标准模式，按照标准来解析和渲染文档。而对于旧的html文档，或没有DOCTYPE声明的文档，则按照怪异模式来解析文档。html5的文档声明方式：&lt;!DOCTYPE HTML&gt; 。 三、标准模式和怪异模式的区别？1、width不同，在标准模式中：width是内容（content）宽度，元素真正的宽度是外边距、内边距、边框宽度的和，即元素宽度 = margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right，在怪异模式中：width则是元素的实际宽度，width = border-left-width + padding-left+ 内容(content)宽度 + padding-right + border-right-width。 2、内联元素的尺寸标准模式中，给span等行内元素设置width和height都不会生效，而在怪异模式下，却会生效。 3、可设置百分比的高度在标准模式下，一个元素的高度由其包含的内容content决定，如果父元素没有设置高度，子元素设置一个百分比高度是无效的。 4、用margin : 0 auto设置水平居中在标准模式下可以使元素水平居中，但是在怪异模式下，无效，可以用text-align : center;来实现居中。 5、怪异模式下设置图片的padding会失效 6、怪异模式下table中的字体属性不能继承上层的设置 7、元素溢出的处理，标准模式下，overflow默认去visible，在怪异模式下，溢出会被当做扩展box来对待，溢出不会裁减，元素框自动调整大小，能够包含溢出内容。","categories":[],"tags":[]},{"title":"HTML5新特性，语义化","slug":"HTML5新特性，语义化","date":"2018-01-13T07:49:00.000Z","updated":"2018-02-12T06:51:55.194Z","comments":true,"path":"2018/01/13/HTML5新特性，语义化/","link":"","permalink":"http://songda1005.cn/2018/01/13/HTML5新特性，语义化/","excerpt":"","text":"一、为什么HTML5要引入新语义标签在HTML5之前采用HTML+CSS文档结构写法，但是这样的布局方式不仅使我们的文档结构不够清晰，而且不利于搜索引擎爬虫对我们页面的爬取。为了解决上述缺点，HTML5新增了很多新的语义化标签。 二、引入语义化标签的优点引入语义化标签的好处主要有下列三点： 比&lt;div&gt;标签有更加丰富的含义，方便开发与维护 搜索引擎能更方便的识别页面的每个部分 方便其他设备解析（如移动设备、盲人阅读器等） 三、标签详解所谓语义化标签就是一种我们仅通过标签名就能判断出该标签内容的语义的标签。下面将介绍&lt;article&gt; &lt;section&gt; &lt;nav&gt; &lt;aside&gt;、&lt;header&gt; &lt;footer&gt;等HTML5新增的语义化区块标签。 （一） header 通常被放置在页面或者页面中某个区块元素的顶部，包含整个页面或者区块的标题、简介等信息，起到引导与导航的作用。 我们不但可以放置页面或者页面中某个区块的标题，还可以放置搜索表单、logo图片等元素，按照最新的W3C标准，我们还可以放置&lt;nav&gt;导航栏。 下面是一个使用该标签的网站头部实例： 1234&lt;header&gt; &lt;img src=&quot;images/logo.png&quot; alt=&quot;**科技&quot; /&gt; &lt;h1&gt;**信息科技有限公司&lt;/h1&gt;&lt;/header&gt; 需要注意的是，一个文档中可以包含一对或者一对以上的&lt;header&gt;标签。标签的位置是次要的，不一定非要显示在页面的上方，我们可以为任何需要的区块标签添加&lt;header&gt;元素，例如下面将要讲解的&lt;article&gt; &lt;section&gt;等标签。 （二）nav 表示页面的导航，可以通过导航连接到网站的其他页面，或者当前页面的其它部分。 &lt;nav&gt;不但可以作为页面独立的导航区域存在，我们还可以在&lt;header&gt;标签中使用。此外，&lt;nav&gt;标签还可以显示在侧边栏中。由此可见，一个页面之中可以有多个&lt;nav&gt;标签。 根据HTML5标准，&lt;nav&gt;标签只用于页面的主要导航部分。因为搜索引擎或者屏幕阅读器会根据&lt;nav&gt;标签来确定网站的主体内容，所以并不是任意一组超链接都适合放置在&lt;nav&gt;标签中,我们只要将主要的，基本的链接组放进&lt;nav&gt;即可,对于有辅助性的页脚链接则不推荐使用&lt;nav&gt;标签。 示例如下： 1234567891011&lt;header&gt; &lt;img src=&quot;images/logo.png&quot; alt=&quot;**科技&quot; /&gt; &lt;h1&gt;**信息科技有限公司&lt;/h1&gt; &lt;nav&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;example.html&quot;&gt;客户案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;service_one.html&quot;&gt;技术服务&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;aboutus_one.html&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;connection.html&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt; &lt;/nav&gt;&lt;/header&gt; 值得我们注意的是,HTML5规范不允许将&lt;nav&gt;标签嵌套在&lt;address&gt;标签中使用。 （三）aside 所包含的内容不是页面的主要内容、具有独立性，是对页面的补充。 &lt;aside&gt;标签一般使用在页面、文章的侧边栏、广告、友情链接等区域 示例如下： 12345678 &lt;article&gt; &lt;h1&gt;HTML5学习之语义化标签&lt;/h1&gt; &lt;p&gt;....正文.....&lt;/p&gt; &lt;aside&gt; &lt;h2&gt;什么是语义化标签&lt;/h2&gt; &lt;p&gt;语义化标签就是......&lt;/p&gt; &lt;/aside&gt;&lt;/article&gt; (四）footer 一般被放置在页面或者页面中某个区块的底部，包含版权信息、联系方式等信息。 跟&lt;header&gt;标签一样，&lt;footer&gt;标签的使用个数没有限制，可以在任意需要的区块底部使用。 示例如下： 12345&lt;footer&gt; &lt;small&gt; 版权所有 © 2016-2017 **信息科技有限公司 &lt;/small&gt;&lt;/footer&gt; （五）article 表示包含于一个文档、页面、应用程序或网站中的一段独立的内容，可以被独立的发布或者重新使用文章标记标签。 &lt;article&gt;标签应该使用在相对比较独立、完整的的内容区块，所以我们可以在一篇博客、一个论坛帖子、一篇新闻报道或者一个用户评论中使用它。通常情况下，一个&lt;article&gt;元素包括标题、正文和脚注。和&lt;nav&gt;标签一样，该标签同样不能用在&lt;address&gt;标签中； 示例如下： 12345&lt;article&gt; &lt;h1&gt;HTML5学习之语义化标签&lt;/h1&gt; &lt;p&gt;....正文.....&lt;/p&gt; &lt;footer&gt;版权所有*伪版必究&lt;/footer&gt;&lt;/article&gt; &lt;article&gt;标签还可以嵌套使用，但是它们必须是部分与整体的关系。例如在一篇发表的博客中，我们可以对读者评论使用该标签。 示例如下： 1234567891011121314151617181920212223&lt;article&gt; &lt;h1&gt;HTML5学习之语义化标签&lt;/h1&gt; &lt;p&gt;....正文.....&lt;/p&gt; &lt;article&gt; &lt;header&gt; &lt;h2&gt;读者评论&lt;/h2&gt; &lt;/header&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;评论人：张三&lt;/h3&gt; &lt;p&gt;评论时间：&lt;time datetime=&quot;2017-02-15&quot;&gt;2017-02-15 11:45:23&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;张三到此一游&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;评论人：李四&lt;/h3&gt; &lt;p&gt;评论时间：&lt;time datetime=&quot;2017-02-09&quot;&gt;2017-02-09 14:20:15&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;李四到此一游&lt;/p&gt; &lt;/article&gt; &lt;/article&gt; &lt;/article&gt; (六）section 是一个主题性的内容分组，通常用于对页面进行分块或者对文章等进行分段 &lt;section&gt;标签所包裹的是有一组相似的主题的内容，可以用这个标签来实现文章的章节、标签式对话框中的各种标签页等类似的功能。 &lt;section&gt;通常包含一个头部&lt;header&gt;、可能还会包含一个尾部&lt;footer&gt;。 示例如下： 12345678910111213141516&lt;article&gt; &lt;h1&gt;JavaScript框架&lt;/h1&gt; &lt;p&gt;Javascript框架是指以Javascript语言为基础搭建的编程框架。&lt;/p&gt; &lt;section&gt; &lt;h2&gt;angular.Js&lt;h2&gt; &lt;p&gt;angular.Js是一款优秀的前端JS框架&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;Vue.js&lt;h2&gt; &lt;p&gt;Vue.js是用于构建交互式的Web界面的库&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;jQuery&lt;h2&gt; &lt;p&gt;jQuery是一个快速、简洁的JavaScript框架。&lt;/p&gt; &lt;/section&gt;&lt;/article&gt; 在这篇关于JS框架的文章中,所列举的三个框架都是文章主题构成的一部分，所以我们使用&lt;section&gt;标签对其进行分段。 我们不但可以在&lt;article&gt;标签中使用&lt;section&gt;标签，还可以在&lt;section&gt;标签中使用&lt;article&gt;标签。 示例如下： 12345678910111213141516&lt;section&gt; &lt;h1&gt;HTML5技术栈&lt;/h1&gt; &lt;p&gt;广义而言的HTML5包含HTML、CSS和JavaScript三个部分&lt;/p&gt; &lt;article&gt; &lt;h2&gt;HTML&lt;h2&gt; &lt;p&gt;内容&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;CSS&lt;h2&gt; &lt;p&gt;样式&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;JavaScript&lt;h2&gt; &lt;p&gt;行为&lt;/p&gt; &lt;/article&gt;&lt;/section&gt; 在这个例子中，&lt;section&gt;标签代表一段内容，在这段内容中，HTML、CSS、Javascript是三个完全独立的部分，因而我们为这三个不同的部分分别使用&lt;article&gt;标签。 &lt;div&gt; &lt;section&gt; &lt;article&gt;三者的比较： &lt;div&gt;：应用广泛，只要我们想为一个区域定义一个样式或者为其添加JS行为，就可以使用div标签 &lt;section&gt;：包含的内容是一个明确的主题，通常有标题区域 &lt;article&gt;:如果我们的页面中需要一个单独的模块来实现一个单独的功能，就用&lt;article&gt;，其他的时候都用&lt;section&gt;。 四、文档级别语义HTML5试图为每个元素加入一个特定的文档级别语义。 （一）ruby、rt、rpruby是一种排版注释系统，是位于横排基础文本上方的简短文字，主要针对东亚语言作出简单的读音注释。例如可以为中文或日文显示读音。ruby涉及的元素包括ruby、rt以及rp。首先使用ruby指定一个具体的表达式，然后使用rt提供说明。rt部分将显示在表达式上方。下面这个例子中，拼音将显示在文字的上方。 1234&lt;ruby&gt; 北&lt;rt&gt;bei&lt;/rt&gt; 京&lt;rt&gt;jing&lt;/rt&gt;&lt;/ruby&gt; 但是在不支持ruby的浏览器中需要使用rp对这两个区块进行视觉上的隔离。 12345678910&lt;ruby&gt; 北 &lt;rp&gt; &lt;rt&gt;bei&lt;/rt&gt; &lt;/rp&gt; 京 &lt;rp&gt; &lt;rt&gt;jing&lt;/rt&gt; &lt;/rp&gt;&lt;/ruby&gt; ####（二）time 为了将现在的常用的日期和时间语句用规范的、利于机器识别的格式进行表述，time元素提供了一个可选的时间和时区组件。 为了确保机器能够正确识别，我们可以使用datetime属性，其属性值可以被定义为时间、日期或者这两者的复合体。 1&lt;time datetime=&quot;2017-07-03&quot;&gt; 还可以使用pubdate为一个网页指定发布时间。 注意：在 HTML5中，true或false并非有效的属性值，当解释器发现存在布尔属性时，它将直接解释为true。如果需要将属性设为false，将这个属性去掉即可。 （三）markmark元素用于高亮标记一段文字。可以使用mark元素来标记出网页里被搜索的关键词或是用于高亮显示一段解释性的代码。（四）wbrwbr元素用于让浏览器为长单词增加可选择的破折号，以便自动拆行。在相当长的单词中插入一对wbr元素，可以让浏览器根据排版的需要决定是否将单词换行。破折号是否出现，以及出现的位置完全由排版决定。wbr只是允许自动拆行，但非强制拆行。（五）略微改变的元素在HTML4版本中的标签元素在HTML5中有了新的定义。使用b表示文档渲染为粗体，而i表示文档渲染为斜体。使用strong和em来强调一段重要的文本。cite用来为对参考文献的引用进行定义，比如书籍或杂志的标题。small不仅仅指的是小字体，它还同样为法律声明增添不具有重要性的旁注或小字。hr现在表达的是主体性的间断，不再仅仅是分割版面的一条水平线。 今天就到这吧朋友们，拜拜","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-01-12T10:59:59.836Z","updated":"2018-02-12T06:47:10.907Z","comments":true,"path":"2018/01/12/hello-world/","link":"","permalink":"http://songda1005.cn/2018/01/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}