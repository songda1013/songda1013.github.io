{"meta":{"title":"inerdstack","subtitle":"the stack of it nerds","description":"start from zero","author":"inerdstack","url":"http://songda1005.cn"},"pages":[],"posts":[{"title":"前端新手常见问题浮动与定位","slug":"前端新手常见问题浮动与定位","date":"2018-06-05T09:14:53.000Z","updated":"2018-06-06T01:12:01.070Z","comments":true,"path":"2018/06/05/前端新手常见问题浮动与定位/","link":"","permalink":"http://songda1005.cn/2018/06/05/前端新手常见问题浮动与定位/","excerpt":"","text":"浮动元素有什么特征？对父容器、其他浮动元素、普通元素、文字分别有什么影响?特征： 浮动元素会正常脱离文档流，按照其外边距指定的位置相对于它的上一个块级元素（或父元素）显示 浮动元素后面的块级元素的内容会向此浮动元素的外边距靠齐，但是边框和背景却忽略 浮动元素会向上一个任意非浮动元素靠齐 浮动元素后面的内联元素会向此浮动元素的外边距靠齐 float造成的影响： 对其父元素的影响 对于父元素来说，元素浮动之后，它会脱离当前正常的文档流，所以它也无法撑开其父元素，造成父元素的塌陷 对其兄弟元素（非浮动）的影响 如果兄弟元素为块级元素，该元素会忽视浮动元素而占据它的位置，并且元素会处在浮动元素的下层，但它的内部文字和其他行内元素都会环绕浮动元素，如果兄弟元素为内联元素，则元素会环绕浮动元素排列。 对其它兄弟元素（浮动）的影响 同一个方向的浮动元素： 当一个元素在浮动在浮动过程中碰到同一个方向的浮动元素时，它会紧跟在它们的后面 反方向浮动元素： 互不影响，位于同一条水平线上，当空间不够时会被挤下来 对子元素的影响 当一个元素浮动时，在没有请浮动的情况下，它无法撑开其父级元素，但它可以让自己的浮动子元素，撑开其自身，并且在没有定义具体宽度的情况下，使自身宽度从 100% 变为自适应（浮动元素 display：block）其高度和宽度均为浮动元素高度和非浮动元素高度之间的最大值。 清除浮动指什么? 如何清除浮动? 两种以上方法浮动：浮动框不属于文档中的普通流，当一个元素浮动之后，不会影响到 块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，也就会出现包含框不会 自动伸高来闭合浮动元素（“高度塌陷”现象）。正是因为浮动的这种特性，导致本属于普通流中的元素浮动之后，包含框内部由于不存在其他普通流元素了，也就表现出高度为 0（高度塌陷）。在实际布局中，往往这并不是我们所希望的，所以需要闭合浮动元素，使其包含框表现出正常的高度 清除浮动的方法： 添加空 div，对他进行处理 12&lt;div style=\"clear: both;\"&gt;&lt;/div&gt;缺点：增加了一个无意义的标签。 BFC 清除浮动（BFC详细请看下面）：在父容器中生成BFC 触发BFC float 除了 none 以外的值 overflow 除了visible 以外的值（hidden，auto，scroll ） display (table-cell，table-caption，inline-block，flex，inline-flex) position值为（absolute，fixed） 局限性：使用 BFC 使用 float 的时候会使父容器长度缩短，而且还有个重要缺陷——父容器 float 解决了其塌陷问题，那么父容器的父容器怎么办？overflow 属性会影响滚动条和绝对定位的元素；position 会改变元素的定位方式，这是我们不希望的，display 这几种方式依然没有解决低版本 IE 问题。。。 通用的清理浮动方案 方法1 12345678.clearfix&#123;*zoom:1;&#125;.clearfix:after&#123;content:\"\";display:block;clear:left;&#125; 方法2 12345678.clearfix&#123;*zoom:1;&#125;.clearfix:after&#123;content:\"\";display:table;clear:both;&#125; 虽然我们得出了一种浏览器兼容的靠谱解决方案，但这并不代表我们一定得用这种方式，很多时候我们的父容器本身需要 position：absolute；等形成了 BFC 的时候我们可以直接利用这些属性了，大家要掌握原理，活学活用。总而言之清理浮动两种方式： 1、利用 clear 属性，清除浮动 2、使父容器形成 BFC 有几种定位方式，分别是如何实现定位的，参考点是什么，使用场景是什么？ static： 默认值，没有定位，元素出现在正常的流中（忽略 top， bottom， left， right 或者 z-index 声明）。当你没有为一个元素(例如 div )指定定位方式时，默认为 static，也就是按照文档的流式( flow )定位，将元素放到一个合适的地方。所以在不同的分辨率下，采用流式定位能很好的自适合，取得相对较好的布局效 relative: 生成相对定位的元素，相对于其正常位置进行定位。元素的位置通过 “left”，”top”， “right” 以及 “bottom” 属性进行规定。在 static 的基础上，如果我想让一个元素在他本来的位置做一些调整(位移)，我们可以将该元素定位设置为relative，同时指定相对位移(利用top，bottom，left，right)。有一点需要注意的是，相对定位的元素仍然在文档流中，仍然占据着他本来占据的位置空间——虽然他现在已经不在本来的位置了。绝对定位会使元素从文档流中被删除，结果就是该元素原本占据的空间被其它元素所填充。 fixed: 元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。我们知道 absolute 定位的参照物是“上一个定位过的父元素( static 不算)”，那么如果我想让一个元素定位的参照物总是整个文档(viewport)，怎么办呢？答案是使用 fixed 定位，fixed 定位的参照物总是当前的文档。利用 fixed 定位，我们很容易让一个 div 定位在浏览器文档的左上，右上等方位。比如你想添加一个信息提示的 div，并将该 div 固定在右上方，你可以使用以下 css 12345.element &#123; position：fixed； top：2%； right：2%；&#125; absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。如果你想在一个文档(Document)中将一个元素放至指定位置，你可以使用 absolute 来定位，将该元素的 position 设置为absolute，同时使用top，bottom，left，right来定位。 元素的位置通过 “left”， “top”， “right” 以及 “bottom” 属性进行规定 z-index 有什么作用? 如何使用?当网页上出现多个由绝对定位（ position:absolute；）或固定定位（ position:fixed；）所产生的浮动层时，必然就会产生一个问题，就是当这些层的位置产生重合时，谁在谁的上面呢？或者说谁看得见、谁看不见呢？这时候就可以通过设置z-index的值来解决，这个值较大的就在上面，较小的在下面。z-index的意思就是在z轴的顺序，如果说网页是由x轴和y轴所决定的一个平面，那么z轴就是垂直于屏幕的一条虚拟坐标轴，浮动层就在这个坐标轴上，那么它们的顺序号就决定了谁上谁下了。 position:relative 和负 margin 都可以使元素位置发生偏移?二者有什么区别？ position:relative；是相对定位可以使元素发生偏移，但是在文档流中，它仍然占据着原来的位置，所以其他元素的位置不会发生变化 负margin：通过负margin进行偏移的元素，它会放弃偏移前占据的空间，这样它后面文档流中的其它元素就会“流”过来填充这部分空间，所以其他元素的位置发生了变化。 在什么场景下会出现外边距合并？如何合并？如何不让相邻元素外边距合并？给个父子外边距合并的范例外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并。 假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并：如果这个外边距遇到另一个元素的外边距，它还会发生合并。 父子元素之间的外边据合并 消除边距合并的方式一：给父元素加边框 消除边距合并的方式二：给父元素加 padding BFC 是什么？如何生成 BFC？BFC 有什么作用？举例说明 BFC 定义： BFC (Block formatting context) 直译为”块级格式化上下文”。它是一个独立的渲染区域，只有 Block-level box参与， 它规定了内部的 Block-level Box如何布局，并且与这个区域外部毫不相干。 Box Box 是 Css 布局的对象和基本单位，直观点来说，就是一个页面有很多 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型，不同类型的 Box，会参与不同的 Formatting Context （一个决定如何渲染文档的容器），因此 Box 内的元素会以不同的方式渲染，让我们看看有哪些盒子： 1、block-level box:display 属性为 block， list-item， table 的元素，会生成 block-level box。并且参与 block fomatting context； 2、inline-level box:display 属性为 inline， inline-block,，inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context Formatting Context Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称 BFC )和 Inline formatting context (简称IFC)。 BFC 布局规则： 内部 Box 会在垂直方向，一个接一个的放位置 Box 的垂直方向的距离有 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠 每个元素的 margin box 的左边，与包含块 border box 的左边相接触，（对于从左向右的格式化，否则相反）。即使存在浮动也是如此 BFC 的区域不会与 float box 重叠 BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也是如此 计算 BFC 的高度时，浮动元素也参与计算 哪些元素会生成 BFC 根元素 float 属性不为 none position 为 absolute 或 fixed display 为 inline-block，table-cell，table-caption，flex，inline-flex overflow 不为 visible BFC的作用： 自适应两栏布局 每个元素的 margin box 的左边，与包含 border box 的左边（对于从左向右的格式化，否则相反）。即使存在浮动也是如此 我们可以通过触发 main 生成 BFC，来实现自适应两栏布局 清除内部浮动 计算 BFC 的高度时，浮动元素也参与计算，解决父容器塌陷问题。 防止垂直 margin 重叠 我们可以在 p 外面包裹一层容器，并触发该容器生成一个 BFC。那么两个 P 便不属于同一个 BFC，就不会发生 margin 重叠了。","categories":[],"tags":[]},{"title":"谈谈dispaly position float","slug":"谈谈dispaly-position-float","date":"2018-06-05T05:09:09.000Z","updated":"2018-06-05T07:06:54.572Z","comments":true,"path":"2018/06/05/谈谈dispaly-position-float/","link":"","permalink":"http://songda1005.cn/2018/06/05/谈谈dispaly-position-float/","excerpt":"","text":"页面布局，或是在页面作一些小效果的时候经常会用到 display position float 属性，如果对它们不是很了解的话，很容易出现一些莫名其妙的效果，痛定思痛总结了一下。 让我们从基础的 Css 谈起，有很多初学者不明白 Css 的原理，一味的追求效果，结果页面漏洞百出，错误匪夷所思，关于盒模型我就不多说了，网上很多，注意一下IE和其他浏览器（W3C规范）的区别就好了。 块元素与行内元素 首先谈谈人们经常提及的块级元素 和 行内(内联)元素 p，ul，form，div 等元素都被称为块元素，这些元素显示一块内容（会自动换行），span，input，等元素称为行内元素，这两者主要区别就是块级元素会从上到下一个个垂直排列，每个自占一行，默认宽度是父级的 100%，默认高度由内容撑开，可以设置宽高，可以任意嵌套，（ p 标签不能嵌套），如下即使两个 div 之间没任何元素，绿色的 div 仍然会显示在红色 div下方，而不是右方 1234&lt;div style=\"height: 100px; width: 100px; background-color: Red;\"&gt;&lt;/div&gt;&lt;div style=\"height: 100px; width: 100px; background-color: Green;\"&gt;&lt;/div&gt; 而行内元素在一行中水平排列，行内元素的高度由其内容撑开，不可显示的设置其高度，可在一行显示，一行显示不下时，自动切换到下一行，不可以设置宽度和高度（ input 和 img 除外），设置上下外边距无效，不能嵌套块标签，其中 a 标签不能嵌套 a 标签，这就是为什么我们一次次的在 span 上设置 height 属性不好使的原因。 简单了解了这些知识，让我们看看display常用的几个属性，一些不太常用的我也不明白，就不说了 display: none； 此元素不会显示 display: block； 此元素将会显示为块级元素，此元素前后将会有换行符 display: inline； 此元素会被显示为内联元素，元素前后没有换行符 display: inline-block； 行内块元素。（CSS2.1 新增的值） 我们在显示隐藏元素的时候经常会用到把 display 设为 none 或者’’，设为 none 效果很明显，就是让元素脱离文档流，不显示，不占文档空间，而设为’’其实就是设置为元素默认属性 block 或 inline，inline-block 属性是CSS2.1新加值，IE8以上及其他主流浏览器都已经支持，它可以使元素像行内元素那样水平一次排列，但是框的内容符合块级元素行为，能够显示设置宽，高，内外边距。很有意思。 还有一点儿很有意思，可以通过不同的赋值改变元素生成框的类型，也就是说，通过将 display 属性设置为block，可以使行内元素表现的想块级元素一样，反之亦然。 定位 要想了解 Css 元素定位就需要了解 position 属性了，position 属性有几个常用值如下: position: insert； 规定应该从父元素继承 position 属性的值。 position: static； 默认值，没有定位，元素出现在正常的流中（忽略 top， bottom，left， right 或者 z-index 声明） position: relative； 生成相对定位的元素，相对于元素本身正常位置进行定位。因此，left: 20px; 会向元素的 left 位置添加 20 像素。 position: absolute；生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。元素的位置通过 left，top ，right 以及 bottom 属性进行规定。 position: fixed；生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 left, top，right 以及 bottom 属性进行规定。 Css 有三种基本的定位机制：普通流，浮动和绝对定位 普通流是默认定位方式，在普通流中元素框的位置由元素在 html 中的位置决定，元素 position 属性为 static或继承来的 static 时就会按照普通流定位，这也是我们最常见的方式。 相对定位比较简单，对应 position 属性的 relative 值，如果对一个元素进行相对定位，它将出现在他所在的位置上，然后可以通过设置垂直或水平位置，让这个元素相对于它自己移动，在使用相对定位时，无论元素是否移动，元素在文档流中占据原来空间，只是表现会改变。 123456789普通流：&lt;div style=\"border: solid 1px #0e0; width:200px;\"&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Red;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Green;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Red;\"&gt; &lt;/div&gt;&lt;/div&gt; 123456789相对定位:&lt;div style=\"border: solid 1px #0e0; width:200px;\"&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Red;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Green; position:relative;top:20px; left:20px;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Red;\"&gt; &lt;/div&gt;&lt;/div&gt; 上面例子可以看出，对绿色 div 进行相对定位，分别右移，下移 20px 后第二个红色 div 位置并没有相应变化，而是在原位置，绿色 div 遮挡住了部分红色 div。 相对定位可以看作特殊的普通流定位，元素位置是相对于他在普通流中位置发生变化，而绝对定位使元素的位置与文档流无关，也不占据文档流空间，普通流中的元素布局就像绝对定位元素不存在一样。 绝对定位的元素的位置是相对于距离他最近的非 static 祖先元素位置决定的。如果元素没有已定位的祖先元素，那么他的位置就相对于初始包含块儿（ body 或 html 神马的）元素。 因为绝对定位与文档流无关，所以绝对定位的元素可以覆盖页面上的其他元素，可以通过 z-index 属性控制叠放顺序，z-index 越高，元素位置越靠上。 还是刚才的例子，稍微改动一下，让绿色 div 绝对定位，为了清晰显示，第二个红色 div 改为黄色。 12345678&lt;div style=\"border: solid 1px #0e0; width:200px; position:relative;\"&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Red;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Green; position:absolute; top:20px; left:20px;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Yellow;\"&gt; &lt;/div&gt;&lt;/div&gt; 这时可以看出，绿色div是相对于父元素，也就是绿框div进行的移位，而红色和黄色div进行布局时就像绿色div不存在一样。 最后要说的就是fixed属性了，应用fixed也叫固定定位，固定定位是绝对定位的中，固定定位的元素也不包含在普通文档流中，差异是元素的包含块儿是视口（ viewport ），经常见一些页面的如人人网看在线好友那个模块总在窗口右下角，估计用的是类似技术 123456789固定定位：&lt;div style=\"border: solid 1px #0e0; width:200px;\"&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Red;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Green; position:fixed; bottom:20px; left:20px;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Yellow;\"&gt; &lt;/div&gt;&lt;/div&gt; 浮动 首先介绍一些浮动模型的基本知识：浮动模型也是一种可视化格式模型，浮动的框可以左右移动（根据 float 属性值而定），直到它的外边缘碰到包含框或者另一个浮动元素的框的边缘。浮动元素不在文档的普通流中，文档的普通流中的元素表现的就像浮动元素不存在一样.《CSS Mastery》里作者画了几个图非常有意思，可以帮助我们理解浮动的表现，我简单的画几个。 123456789不浮动：&lt;div style=\"border: solid 5px #0e0; width:300px;\"&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Red;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Green; \"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Yellow;\"&gt; &lt;/div&gt;&lt;/div&gt; 123456789红向右浮动:&lt;div style=\"border: solid 5px #0e0; width:300px;\"&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Red; float:right;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Green; \"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Yellow;\"&gt; &lt;/div&gt;&lt;/div&gt; 123456789红框左移,覆盖绿框 :&lt;div style=\"border: solid 5px #0e0; width:300px;\"&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Red; float:left;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Green;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Yellow;\"&gt; &lt;/div&gt;&lt;/div&gt; 123456789都向左浮动,父元素宽度为0 &lt;div style=\"border: solid 5px #0e0; width:300px;\"&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Red; float:left;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Green; float:left;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Yellow; float:left;\"&gt; &lt;/div&gt;&lt;/div&gt; 如果包含块儿太窄无法容纳水平排列的三个浮动元素,那么其它浮动块儿向下移动,,直到有足够的扣减,如果浮动元素的高度不同,那么下下移动的时候可能被卡住 123456789没有足够水平空间:&lt;div style=\"border: solid 5px #0e0; width:250px;\"&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Red; float:left;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Green; float:left;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Yellow; float:left;\"&gt; &lt;/div&gt;&lt;/div&gt; 123456789卡住了:&lt;div style=\"border: solid 5px #0e0; width:250px;\"&gt; &lt;div style=\"height: 120px; width: 100px; background-color: Red; float:left;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Green; float:left;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Yellow; float:left;\"&gt; &lt;/div&gt;&lt;/div&gt; 行框和清理 前面指出浮动会让元素脱离文档流,不影响不浮动元素.实际上并不完全如此,如果浮动的元素后面有一个文档流中元素,那么这个元素的框会表现的像浮动元素不存在,但是框的文本内容会受到浮动元素的影响,会移动以留出空间.用术语说就是浮动元素旁边的行框被缩短,从而给浮动元素流出空间,因而行框围绕浮动框。 12345678不浮动:&lt;div style=\"border: solid 5px #0e0; width: 250px;\"&gt; &lt;div style=\"height: 50px; width: 50px; background-color: Red;\"&gt;&lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Green;\"&gt; 11111111111 11111111111 &lt;/div&gt;&lt;/div&gt; 12345678浮动： &lt;div style=\"border: solid 5px #0e0; width: 250px;\"&gt; &lt;div style=\"height: 50px; width: 50px; background-color: Red; float:left;\"&gt;&lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Green;\"&gt; 11111111111 11111111111 &lt;/div&gt;&lt;/div&gt; 可以看出浮动后虽然绿色 div 布局不受浮动影响，正常布局，但是文字部分却被挤到了红色浮动 div 下边。要想阻止行框围绕在浮动元素外边，可以使用 clear 属性，属性的left，right，both，none 表示框的哪些边不挨着浮动框。 1234567&lt;div style=\"border: solid 5px #0e0; width: 250px;\"&gt; &lt;div style=\"height: 50px; width: 50px; background-color: Red; float:left;\"&gt;&lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Green; clear:both;\"&gt; 11111111111 11111111111 &lt;/div&gt;&lt;/div&gt; 对元素清理实际上为前面的浮动元素留出了垂直空间,这样可以解决我们之前的一个问题，看前面的图片的时候我们发现 div 内的所有元素浮动的话就会不占据文档空间，这样父元素，高度为 0，可能很多效果也不见了 123456789都向左浮动,父元素宽度为0&lt;div style=\"border: solid 5px #0e0; width:300px;\"&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Red; float:left;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Green; float:left;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Yellow; float:left;\"&gt; &lt;/div&gt;&lt;/div&gt; 如果我们想让父元素在视觉上包围浮动元素可以向下面这样处理 12345678910在最后添加一个空div，对它清理&lt;div style=\"border: solid 5px #0e0; width:300px;\"&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Red; float:left;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Green; float:left;\"&gt; &lt;/div&gt; &lt;div style=\"height: 100px; width: 100px; background-color: Yellow; float:left;\"&gt; &lt;/div&gt; &lt;div style=\"clear:both;\"&gt;&lt;/div&gt;&lt;/div&gt; 当然这样做有很多缺点，有些 javascript 也可以做出类似效果，这里不细说，值得注意的是应用值为 hidden 或auto 的 overflow 属性会有一个副作用：自动清理包含的任何浮动元素，所以说当页面出现相关问题时，可以看看是不是这个属性搞的鬼。 这样，有了这些基本知识后，我们应用CSS的时候就可以解决很多以前很百思不得其解的问题了。","categories":[],"tags":[]},{"title":"16中方法实现水平居中垂直居中","slug":"16中方法实现水平居中垂直居中","date":"2018-06-05T02:58:07.000Z","updated":"2018-06-05T07:10:46.133Z","comments":true,"path":"2018/06/05/16中方法实现水平居中垂直居中/","link":"","permalink":"http://songda1005.cn/2018/06/05/16中方法实现水平居中垂直居中/","excerpt":"","text":"水平居中1、若是行内元素，给父元素设置 text-align:center; 既可以实现行内水平居中 2、若是块级元素，该元素设置 margin：0 auto； 即可 3、若是子元素包含，float:left 属性，为了让子元素水平居中，则可以让父元素宽度设置成 fit-content ，并配合 margin ，作如下设置： 123456.parent &#123; width: -moz-fit-content; width: -webkit-fit-content; width:fit-content; margin:0 auto;&#125; fit-content 是 CSS3 中给 width 属性新加的一个属性值,它配合 margin 可以轻松实现水平居中, 目前只支持Chrome 和 Firefox 浏览器 4、使用 flex 2012 版本布局，可以轻松的实现水平居中，子元素设置如下 1234.demo &#123; display: flex; justify-content: content;&#125; 5、使用flex 2009年版本, 父元素 display: box; box-pack: center; 如下设置: 1234567891011121314151617.parent &#123; display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-pack: center; display: -moz-box; -moz-box-orient: horizontal; -moz-box-pack: center; display: -o-box; -o-box-orient: horizontal; -o-box-pack: center; display: -ms-box; -ms-box-orient: horizontal; -ms-box-pack: center; display: box; box-orient: horizontal; box-pack: center;&#125; 6、使用 CSS3 中新增的 transform 属性，子元素设置如下： 12345.demo &#123; position:absolute; left:50%; transform:translate(-50%,0);&#125; 7、使用绝对定位方式，以及负值的 margin-left ，子元素设置如下 123456.demo &#123; position:absolute; width:固定; left:50%; margin-left:-0.5宽度;&#125; 8、使用绝对定位方式, 以及 left:0; right:0; margin:0 auto; 子元素设置如下: 1234567.demo &#123; position:absolute; width:固定; left:0; right:0; margin:0 auto;&#125; 垂直居中 单行文本： 1、若是元素为单行文本，则可设置 line-height 等于父级的高度 行块内元素： 1、若是行内块元素，基本思想是使用 display: inline-block，vertical-align: middle 和一个伪元素让内容处于容器中央 12345678.parent::after, .demo &#123; display:inline-block; vertical-align:middle;&#125;.parent::after &#123; content:''; height:100%;&#125; 这是一种很流行的方法, 也适应IE7. 元素高度不定 1、可用 vertical-align 属性, 而 vertical-align 只有在父层为 td 或者 th 时， 才会生效，对于其他块级元素，例如 div、p 等, 默认情况是不支持的. 为了使用 vertical-align， 我们需要设置父元素 display:table，子元素 display:table-cell; vertical-align:middle; 优点：元素高度可以动态改变, 不需再 CSS 中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断. 缺点：IE6~7, 甚至IE8 beta中无效 2、可用 Flex 2012版, 这是 CSS 布局未来的趋势， Flexbox 是 CSS3 新增属性, 设计初衷是为了解决像垂直居中这样的常见布局问题. 相关的文章如《弹性盒模型Flex指南》 父元素做如下设置即可保证子元素垂直居中: 1234.parent &#123; display: flex; align-items: center;&#125; 优点： 内容块的宽高任意, 优雅的溢出 可用于更复杂高级的布局技术中 缺点： IE8/IE9 不支持 需要浏览器厂商前缀 渲染上可能会有一些问题 3、使用 flex 2009版 12345.parent &#123; display: box; box-orient: vertical; box-pack: center;&#125; 优点：实现简单, 扩展性强 缺点：兼容性差, 不支持 IE 4、可用 transform , 设置父元素相对定位 (position:relative)，子元素如下 css 样式 1234567.demo &#123; position:absolute; top:50%; -webkit-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); transform: translate(-50%,-50%);&#125; 优点：代码量少 缺点：IE8 不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象 元素高度固定 1、设置父元素相对定位 (position:relative)， 子元素如下 css 样式: 123456.demo &#123; position:absolute; top:50%; height:固定; margin-top:-0.5高度;&#125; 优点：适用于所有浏览器. 缺点：父元素空间不够时, 子元素可能不可见(当浏览器窗口缩小时,滚动条不出现时).如果子元素设置了overflow:auto, 则高度不够时, 会出现滚动条 2、设置父元素相对定位 (position:relative)， 子元素如下 css 样式: 1234567.demo &#123; position:absolute; height:固定; top:0; bottom:0; margin:auto 0;&#125; 优点：简单 缺点：没有足够的空间时，子元素会被截断，不会有滚动条 总结：水平居中较为简单, 共提供了 8 种方法，一般情况下 text-align:center，marin:0 auto; 足矣 ① text-align:center; ② margin:0 auto; ③ width:fit-content; ④ flex ⑤ 盒模型 ⑥ transform ⑦ ⑧ 两种不同的绝对定位方法 垂直居中, 共提供了8种方法 ① 单行文本，line-height ② 行内块级元素, 使用 display: inline-block， vertical-align: middle;加上伪元素辅助实现 ③ vertical-align ④ flex ⑤ 盒模型 ⑥ transform ⑦ ⑧ 两种不同的绝对定位方法 我们发现，flex， 盒模型， transform， 绝对定位， 这几种方法同时适用于水平居中和垂直居中 希望对大家有所帮助 本文作者：A-D 参考文章：http://louiszhai.github.io/2016/03/12/css-center/","categories":[],"tags":[]},{"title":"CSS实现隐藏页面的5种方式","slug":"CSS实现隐藏页面的5种方式","date":"2018-06-05T01:03:20.000Z","updated":"2018-06-05T07:12:24.036Z","comments":true,"path":"2018/06/05/CSS实现隐藏页面的5种方式/","link":"","permalink":"http://songda1005.cn/2018/06/05/CSS实现隐藏页面的5种方式/","excerpt":"","text":"用 Css 隐藏页面也很多方法，你可以讲 opacity 设置为 0、将 visibility 设为 hidden、将 dispaly 设为 none 或者将 position 设为 absolute 然后将位置移动到不可见的区域 你有没有想过为什么我们有这么多技术来隐藏这些元素，而看起来他们实现的效果都是一样的，其实每一种方法和其他的方法之间都有一些细微的不同，这些不同决定了在一些特定的场合下使用哪一种方法，这篇教程将覆盖到那些你需要记住的细小不同点，让你根据不同的情况下，选择使用哪种方法隐藏元素 Opacityopacity 属性的意识就是设置让一个元素的透明度，它不是为了改变元素的边界框（bounding box) 而设计的，这意味着将 opacity 设置为 0 只能从视觉上隐藏，而元素本身依然占据着它的位置并对网页的布局起作用，它也将相应用户交互 .hide { opacity: 0; } 如果你打算使用 opacity 属性在读屏软件中隐藏，很不幸，你并不能如你所愿。元素和它的所有内容会被读屏软件阅读，就像网页上的其他元素那样。换句话说，元素的行为就和它们不透明时一致 我还要提醒一句，opacity 属性可以用来实现一些效果很棒的动画。任何 opacity 属性值小于 1 的元素也会创建一个新的堆叠上下文（stacking context)。 看下面的列子： 看 @SitePoint 提供的例子“用 opacity 隐藏元素” 当你鼠标移到被隐藏的第 2 个区块上，元素状态平滑地从完全透明变成不透明，区块也将 cursor 属性设置为了 pointer ，这说明用户可以与它交互 Visibility第二个要说的属性是 Visibility。将它的值设为 hidden 将隐藏我们的元素。如同 opacity 属性，被隐藏的元素依然会对我们的网页布局起作用。与 opacity 唯一不同的是它不会响应用户的任何交互。此外，元素在读屏软件中也会被隐藏。 这个属性也能实现动画效果，只要它的初始的结束状态不一样。这确保了 Visibility 状态切换之间的过渡动画可以是时间平滑的，（事实上可以用这一点来用 hidden 实现元素的延迟显示和隐藏——译者注）。 .hide { ​ visibility: hidden; } 下面的例子演示了 visibility 与 opacity 有怎么样的不同： 看 @SitePoint 提供的例子“用 visibility 隐藏元素” 注意，如果一个元素的 visibility 被设置为 hidden，同时想要显示它的子孙元素，只要将那个元素的 visibility 显示设置为 visible 即可（就如例子里面的 .o-hide p——译者注）。尝试只 hover 在隐藏元素上，不要 hover 在 p 标签里的数字上，你会发现你的鼠标光标没有变成手指头的样子，此时，你点击鼠标，你的 click 时间也不会触发。 而在 &lt;div&gt; 标签里面的 &lt;p&gt; 标签则依然可以捕获所有的鼠标事件。一旦你的鼠标移动到文字上，&lt;div&gt; 本身变得可见并且事件注册也会随之生效 Displaydisplay 属性依照词义真正隐藏元素。将 display 属性设为 none 确保元素不可见并且连盒模型都生成不了，使用这个属性，被隐藏的元素不占任何空间，不仅如此，一旦 display 设为 none，任何对该元素直接打用户交互操作都不能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在。 任何这个元素的子孙元素也会被同时隐藏。为这个属性添加过度效果是没有任何效果的，它的任何不同状态值之间的切换总是立即生效 不过注意通过 DOM 依然可以访问到这个元素。因此你可以通过 DOM 来操作它，就像操作其他元素。 .hide{ display: none； } 看下面的列子： @SitePoint 提供的例子“用 display 隐藏元素” 你将看到第二个元素内有一个&lt;p&gt; 元素，它有自己的 display 属性被设置成 black，但是它依然不可见。这是 visibility:hidden 和 display:none 的另一个不同之处。在前一个例子里，将任何子孙元素 Visibility 显示设置成 visible 可以让它变得可见，但是 display 不吃这一套，不管自身 display 值是什么，只要祖先 display:none ，它们就都不可见 现在，将鼠标移到第一个块元素上面几次，然后点击它。这个操作将让第二个块元素显现出来，它其中的一个数字将是一个大于 0 的数。这是因为，元素即使设置成对用户隐藏，还是可以通过 JavaScript 来操作的 Position假设有一个元素它想要与你交互，但是你又不想让它影响你的网页布局，没有合适的属性可以处理这种情况，（opacity 和 visibility 影响布局， display 不影响布局但又无法直接交互——译者注）。在这种情况下，你只能考虑将元素移出可是区域。这个办法既不会影响布局，也能让元素保持可以操作，下面是采用这种办法的 CSS .hide{ position: absolute; top: -9999px; left: -9999px; } 下面列子阐明了怎样通过绝对定位的方式来隐藏元素，并让他和前面的效果一样： 看 @SitePoint 提供的例子“用 position 属性隐藏元素” 这种方法是通过元素的 top 值 left 值设置成绝大负数，来该变元素的位置，使它不可见，采用这个技术的一个好处就是，（或者潜在的缺点）是用它隐藏的元素的内容可以被读屏软件读取。这完全可以理解，是因为你只是将元素移到可视区域外面让用户无法看到它。 你得避免使用这种方法去隐藏任何可以获取焦点的元素，因为如果这么做，当用户获取焦点的时候，会导致一个不可预料的焦点切换，这个方法在创建复选框和单选框按钮时，经常被使用。（用 DOM 模拟复选框和单选按钮，但用这个方法隐藏真正的 checkbox 和 radio 元素来“接收”焦点切换——译者注） Clip-path隐藏元素的另一种方法是通过裁剪它们来实现，在以前，这可以通过 clip 属性来实现，但是这个属性被废弃了，换成一个更好的属性叫 clip-path 。Nitish Kumar 最近在 SitePoint 发表了“介绍 clicp-path 属性”这篇文章，通过阅读它可以了解这个属性的更多高级用法。 记住 clip-path 属性还没有在 IE 和 Edge 下被完全支持，如果你要在你的 clip-path 中使用外部的 SVG 文件，浏览器支持还会更低。使用 clip-path 方式如下 .hide{ clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px); } 下面是一个实际使用的列子： 看 @SitePoint 提供的例子“用 clip-path 属性隐藏元素” 如果你把鼠标悬停在第一个元素上，它依然可以影响第二个元素，尽管第二个元素已经通过 clip-path 隐藏了。如果你点击它，它会移除用来隐藏的 class，让我们的元素从那个位置显现出来。被隐藏元素中的文字仍然能够通过读屏软件读取，许多 WordPress 站点使用 clip-path 或者之前的 clip来实现专门为读屏软件提供的文字。 虽然我们的元素自身不再显示，它也依然占据本该占据的矩形大小，它周围的元素的行为就如同它可见时一样。记住用户交互例如鼠标悬停或者点击在剪裁区域之外也不可能生效。在我们的例子里，剪裁区大小为零，这意味着用户将不能与隐藏的元素直接交互。此外，这个属性能够使用各种过渡动画来实现不同的效果。 总结：在这篇教程里，我们看了 5 种不同的通过 CSS 隐藏元素的方法。每一种方法都与其他几种有一点区别。知道你想要实现什么有助于你决定采用哪一个属性，随着时间推移，你就能根据实际需求本能地选择最佳方式了。 原文：http://www.zcfy.cc/article/457","categories":[],"tags":[]},{"title":"IE8项目总结","slug":"IE8项目总结","date":"2018-05-29T08:34:12.000Z","updated":"2018-06-05T07:14:22.654Z","comments":true,"path":"2018/05/29/IE8项目总结/","link":"","permalink":"http://songda1005.cn/2018/05/29/IE8项目总结/","excerpt":"","text":"公司最近接了一个兼容 IE 的项目，之前没有做过兼容 IE 的项目感觉也就和之前的差不多，但是做起来之后才之后那是差一条街啊，首先总结一下在 IE 下什么都不好用了 meta设置1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; Jquery 如果项目要用 Jquery 的话就必须是 2.0 一下版本的才好用，因为 IE8 以下只兼容 2.0 一下的版本 border-radius在 IE 浏览器下 border-radius 圆角是不兼容的，解决办法，实际上是指的是一个名为 pie 的 htc 文件，即pie.htc，使用 CSS 的 behavior 行为，可以调用此文件，然后让 IE 也能实现一些常见的 CSS3 效果，如圆角(border-radius)，盒阴影 (box-shadow)，背景渐变 (gradient)，多图片背景 (multiple background images)，但是这个 htc 文件文件必须在你项目 html 同级目录下，如果不在同一级目录下，引用的话就会没有效果，下面是引用的样式 123456789box &#123; width: 14px; height: 14px; border-radius: 8px; background: #ffffff; border: 1px solid #fff; cursor: pointer; behavior:url(../WEBINF/pie.htc); &#125; 下载地址: https://github.com/lojjic/PIE/downloads 音频视频因为 html5 所有的标签不兼容 IE8 所以想要播放视频和音频的话也只能用插件了，所以为大家推荐了一个播放视频音频的插件，很好用，但是需要一些配置，也是挺麻烦的，但是比起其他插件的话，这个已经很好了，具体的用法，大家去看中文的文档吧 下载地址: http://www.jplayer.cn/developer-guide.html","categories":[],"tags":[]},{"title":"基于vue-cli脚手架使用vue-router路由","slug":"基于vue-cli脚手架使用vue-router路由","date":"2018-05-19T02:00:51.000Z","updated":"2018-06-05T08:33:16.586Z","comments":true,"path":"2018/05/19/基于vue-cli脚手架使用vue-router路由/","link":"","permalink":"http://songda1005.cn/2018/05/19/基于vue-cli脚手架使用vue-router路由/","excerpt":"","text":"上一个讲了 vue-cli 的安装方式，我们就趁热打铁，来学习一下，vue-router 的使用方法，首先我们需要安装一下路由需要安装到生产环境下的，执行以下命令 $ npm i vue-router 我们安装完路由之后就要去使用它，再次声明这个是基于 vue-cli 来配置的所以我们应该先去 src目录下有一个叫main.js 文件去进行配置 12345678910111213141516171819202122232425262728import App from './App'; // 最大的组件import VueRouter from 'vue-router' // 先引入要用的vue-routerimport Commodity from './components/commodity/commodity.vue' // 引入你跳转的那个组件页面我这一共是三个import Comment from './components/comment/comment.vue'import Merchant from './components/merchant/merchant.vue'// new Vue(&#123; // el:'body' 这个就可以删掉了，因为我们已经用Vue.extend方法绑定了// &#125;)let app = Vue.extend(App) // 先绑定App这个组件router.map(&#123; '/Commodity': &#123; component: Commodity &#125;, '/Comment': &#123; component: Comment &#125;, '/Merchant': &#123; component: Merchant &#125;&#125;)router.start(app, #app) // 这句话是开始使用的意识，绑定app，如果报错了的话，可以去你项目个目录的index.html 文件，加上 &lt;div id=\"app\"&gt;&lt;/div&gt; 就好了 // 我们也可以指定你想要跳转的路由页面用这个方法router.go('/Component') // 这样就可以指定路由页面了 我们基本的路由页面就搭建好了，赶紧试试吧","categories":[],"tags":[]},{"title":"Vue-cli脚手架搭建","slug":"Vue-cli脚手架搭建","date":"2018-05-18T09:13:58.000Z","updated":"2018-06-05T08:41:06.613Z","comments":true,"path":"2018/05/18/Vue-cli脚手架搭建/","link":"","permalink":"http://songda1005.cn/2018/05/18/Vue-cli脚手架搭建/","excerpt":"","text":"安装：1、只限于 Linux 版本，首先我们先全局安装一下 $ npm i -g vue-cli 2、全局安装完之后，我们执行 $ vue list 这是查看 vue 给我们提供的脚手架的版本，有很多，我用的就是 webpack 3、选择我们用要使用的版本 $ vue init webpack test-exercise 这是安装我们要使用的版本 webpack 后面跟的是我们的项目名称 4、进入项目中，然后把看我们 package.json 文件里面有很多依赖，这些依赖有开发环境的，还有生产环境的依赖，是项目中需要的，所以我们需要执行以下命令 $ npm i 命令执行完之后会生成一个 node_modules 文件这个文件就是我们项目中所用到的所有插件的文件 5、然后我们该把项目运行一下，执行以下命令 $ npm run dev 这个命令是在 package.json 文件 “scripts” 配置的，”scripts”是一个对象，里面配置的就是我们要执行的命令，因为命令太长，所以给缩写了，然后运行，你也可以自己改这些命令 6、我们也可以打包看一下，打包之后的文件，打包之后会生成一个 dist 文件，这个文件就是用 webpack 打包之后生成的文件，线上用的就是这个文件，这些都不用你去自己去配置，因为 vue-cli 脚手架已经帮我们配置好了，你直接在里面改就可以了，执行以下命令 $ npm run build 7、这个时候我们的项目就跑起来了","categories":[],"tags":[]},{"title":"移动端适配","slug":"移动端适配","date":"2018-05-14T01:00:15.000Z","updated":"2018-06-05T08:36:06.395Z","comments":true,"path":"2018/05/14/移动端适配/","link":"","permalink":"http://songda1005.cn/2018/05/14/移动端适配/","excerpt":"","text":"最近公司写了一个移动端的项目，然后我简单说一下移动端适配的方案，其实移动端适配的方案有很多种，主要是rem，vh，vw，这些每个都有每个的好处，我用的就是 rem 来设置的移动自适应的配置，首先需要 viewport 设置一下，在不同的手机上要自适应屏幕，我是改的是 font-size 的字体大小，用js来改变的，下面是js文件的内容 123456789101112131415161718 (function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; if(clientWidth&gt;=750)&#123; docEl.style.fontSize = '100px'; &#125;else&#123; docEl.style.fontSize = 100 * (clientWidth / 750) + 'px'; &#125; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); 这是用来设置字体大小的，把这个文件引入你要写的项目中，就可以自适应屏幕了，而且不用刷新，然后用 rem 单位来设置，width，height，margin，padding，position只要是涉及到这些都用 rem 来做单位，除了设置 border 可以用1px之外，这些用的都是 rem，正常情况下这些就够了，如果不够的话，可以用媒体查询来配合 rem 来使用，这些足够来自适应屏幕了，好了这次的分享结束，朋友们，我们下回见","categories":[],"tags":[]},{"title":"React中如何能省略不必要的渲染!","slug":"如何能省略不必要的渲染","date":"2018-04-02T01:05:32.000Z","updated":"2018-04-04T07:46:29.038Z","comments":true,"path":"2018/04/02/如何能省略不必要的渲染/","link":"","permalink":"http://songda1005.cn/2018/04/02/如何能省略不必要的渲染/","excerpt":"","text":"我们除了 render 函数，shouldComponentUpdate 可能是 React 组件生命周期最重要的一个函数了，说 render函数重要，是因为 render 函数决定了该渲染什么，而 shouldComponentUpdate 而是决定了，一个组件什么时候不需要渲染。 render 和 shouldComponentUpdate 函数，也是 React 生命周期函数中只有这两个有返回值的函数，render函数的返回结果是构造 DOM 对象的，而 shouldComponentUpdate 函数返回的是一个布尔值，告诉 React 库这个组件在这次更新中是否要继续。 在更新过程中 React 库首先要调用 shouldComponentUpdate 函数，如果这个函数返回 true，那就会继续更新过程，接下来调用 render 函数，如果返回 false，那就立刻停止更新过程，也就不会引起后续的渲染了 说 shouIdComponentUpdate 重要，就是说只要使用恰当，会大大提升 React 组件的性能，如果没有必要渲染的话就不用渲染，这样会更大提升React组件的性能 render 是一个纯函数，这个纯函数的逻辑输入就是 props 和 state 值，如果我们要定义shouIdComponentUpdate 那就根据这两个参数，外加 this.props 和 this.state 来判断出是返回 true 还是返回 false，默认的是返回 true","categories":[],"tags":[]},{"title":"React中什么是Virtual DOM?","slug":"React中什么是虚拟DOM","date":"2018-03-30T09:46:57.000Z","updated":"2018-03-30T15:22:58.606Z","comments":true,"path":"2018/03/30/React中什么是虚拟DOM/","link":"","permalink":"http://songda1005.cn/2018/03/30/React中什么是虚拟DOM/","excerpt":"","text":"我们来说一下什么是 Virtual DOM，之前对这个问题，了解的不是特别的深刻，前几天在网上查找资料，加上自己的理解，来说一下这个虚拟 DOM。 React 应用是通过重复渲染来实现的用户的交互，你可能会想，这样的重复渲染会不会效率太低了，在 jQuery 的实现方式中，我们可在控制台清楚的看见，每次只有需要变化的那一个 DOM 元素被修改，可是，在 React 实现方式中，每次 render 被调用的时候，都要把整个组件都渲染一遍，这样看起来是不是有点浪费呢。 事实上不是这样的，React 利用 Virtual DOM，让每次渲染都渲染最少的 DOM 元素 要了解 Virtual DOM，首先就要了解 DOM，DOM 是结构化文本的抽象表达方式，特定与web环境中，这个结构化文本就是HTML，HTML 中的每一个元素都对应着 DOM 的每个节点，这样因为HTML中的逐级包含关系，DOM节点自然就构成了一个树形结构，称为 DOM 树 浏览器为了渲染 HTML 格式的网页，会将HTML文本解析构建 DOM 树，然后根据DOM树，来渲染用户看到的界面，当要改变界面的内容的时候，就会改变 DOM 树上的节点 Web 前端关于性能优化有一个原则，尽量减少 DOM 操作，虽然 DOM 操作知识一些简单的 JavaScript 代码，但是 DOM 操作会引起浏览器对页面进行重新布局，重新绘制，这就是比 JavaScript 语句执行慢很多的过程 总结：既然 DOM 树是对HTML的抽象，那 Virtual DOM 就是对 DOM 树的抽象。Virtual DOM 不会触及浏览器的部分，只存在 JavaScript 树形结构中，每次自上而下的渲染React组件时，会对比这次的 Virtual DOM 和上一次渲染的 Virtual DOM，对比就会发现差别，然后就修改 DOM 树中有变化的地方就行了","categories":[],"tags":[]},{"title":"为什么使用React","slug":"为什么使用React","date":"2018-03-30T08:54:17.000Z","updated":"2018-03-30T09:40:57.014Z","comments":true,"path":"2018/03/30/为什么使用React/","link":"","permalink":"http://songda1005.cn/2018/03/30/为什么使用React/","excerpt":"","text":"为什么使用React呢 React社区完善，Facebook 支撑，并且拥有强大的全家桶 这里是 React 的中文社区http://react-china.org/ React 只是处理的 View 层，并且使用单项的数据流的方式，让数据决定视图如何展示，利于组件化，复用，提高了可维护性，可扩展性 JSX语法，颠覆了传统的 web 前端思想 各种浏览器插件易于调试，相对于 Vue 来说，API 足够少，没有升级版本所带来的痛点（参考 Vue 1.0 升级 2.0）","categories":[],"tags":[]},{"title":"CSS3新特性的概述","slug":"CSS3新特性的概述","date":"2018-03-29T14:47:21.000Z","updated":"2018-06-05T08:38:18.947Z","comments":true,"path":"2018/03/29/CSS3新特性的概述/","link":"","permalink":"http://songda1005.cn/2018/03/29/CSS3新特性的概述/","excerpt":"","text":"CSS3新特性大致分为一下六类 CSS3选择器 CSS3边框与圆角 CSS3背景与渐变 CSS3过渡 CSS3变换 CSS3动画 下面说一下以上六类都有哪些内容 CSS3选择器1、基本选择器基本选择器又分为 子选择器 相邻兄弟选择器 通用兄弟选择器 群组选择器 2、属性选择器1、element[attribute] 带有attribute属性的元素设置样式 2、element[attrbute=’value’] 带有attribute=’value’的元素设置样式 3、element[attribute~=’value’] 带有attribute属性值中，包含单词value的元素设置样式 4、element [ attribute = ‘value’]* 带有attribute属性值中，包含value的元素设置样式 5、element[attribute^=’value’] 带有attribute属性值中，以value开头的元素设置样式 6、element[attribute$=’value’] 带有 attribute 属性值中，以 value 结尾的元素设置样式 注意比较3和4的区别 3、伪类选择器 动态伪类 定义：这些伪类一般不出现HTML中，只有当用户和网站交互的时候才能体现出来 1、锚点伪类 : link : visited 2、用户行为伪类 : hover : active : focus 3、目标伪类 : target 当我们点击锚点链接的时候，对应的id元素会显示在视口 4、checked状态伪类 这里我们只要知道 checkbox 只能设置宽高，不能设置背景和边框，如果想要设置那我们需要用 appearance:none; 来清除 input 的默认样式 CSS3结构类： nth 选择器 :first-child/last-child 语法： element:first-child 选择属于父元素的首个/最后一个子元素的每个 element 元素，注意 element 为子元素。 `:nth-child(n)` 选择某元素下的第n个 element 元素（n是一个简单的表达式，不能用其他的字母代替），括号里还可以传 odd和 even 两个关键字 :nth-last-child(n) 选择某个元素下的n个 element 子元素，从最后一个子元素计算 :nth-of-type(n) 语法： element:nth-of-type(n) 匹配属于父元素的特定类型的第n个子元素，element 为指定类型的子元素 :nth-last-of-type 匹配属于父元素的特定类型的第n个子元素，从最后一个计数 :first-of-type/:last-of-type 匹配属于其父元素的特定类型的首个/最后一个子元素的每个元素 :only-child 匹配属于父元素的唯一子元素的每个元素 :only-of-type匹配属于其父元素特定类型的唯一子元素的每个元素 :empty 匹配没有子元素（包括文本节点）的每个元素 否定选择器：not 定义：匹配非 元素或者选择器 的每个元素 语法：父元素：not（子元素或者选择器） 例如：ul:not(span){} 伪元素（也可以使用：） element::first-line定义：对元素的第一行文本进行设置，只能用于块级元素element::first-letter定义：用于向文本的首字母设置特殊样式，只能用于块级元素element::before定义：在元素的内容前面插入新内容，常与 content 配合使用element::after定义：在元素的内容后面插入新内容，常与 content 配合使用element::selection 定义：用于设置浏览器中选中文本后的背景色与前景色 伪元素与元素的区别：无法通过js获取DOM 无法通过浏览器开发工具直接查看 伪元素默认是 inline 使用伪元素注意事项：1、使用伪元素 before 和 after 必须设置 content 2、使用伪元素 before 和 after 显示背景图，一定要使用 display 设置为块元素 3、使用伪元素 before 和 after 设置为 display： link-block，需要再次设置 vertical-align:middle CSS3边框与圆角1.CSS3圆角border-radius定义：可以为元素添加圆角边框（块元素，行内块元素，行元素） 属性： border-top-left-radius：左上角 border-top-right-radius：右上角 border-bottom-right-radius 右下角 border-bottom-left-radius 左下角 属性值 ：四个值：左上角 、右上角、 右下角、 左下角 三个值：左上角、右上角和左下角、右下角 两个值：左上角和右下角、右上角和左下角 一个值：4个角都生效 border-radius 中的属性值由两个参数值构成: value1 / value2，值之间用/分隔，value1代表圆角的水平半径，value2代表圆角的垂直半径 圆形与随圆： 一旦使用百分比，参照的是元素本身的高度与宽度当拿50%时，宽等于高为圆形 宽不等于高为椭圆形 2.盒模型box-shedow定义：可以控制一个或多个下拉阴影的框 语法：box-shadow: 水平方向的偏移量、垂直方向的偏移量、模糊程度、扩展程度、颜色、是否具有内阴影 属性值的介绍： 偏移量 1234把元素左上角（0，0）作为基准点，找水平方向和垂直方向的偏移量水平： 正值 --- 右 ，负值 --- 左垂直： 正值 --- 下 ，负值 --- 上 模糊程度： 12边界模糊，但是边界线未动由边界线向外模糊多少像素 扩展程度： 1盒子阴影，上下左右都向外扩展多少像素 是否具有内阴影 1234inset(默认没有，也就是默认是外阴影)加上inset,盒子的阴影为内阴影扩展程度可为负值，但是模糊程度不可以 CSS3背景与渐变 background-image: 语法： background-image:url(&#39;1.jpg),url(&#39;2.jpg&#39;) 使用逗号把图片分开 注意：元素引入多个背景图片，前面图片会覆盖后面的图片 background-clip: 定义：指定背景的绘制区域（裁剪） 语法： background-cilp: border-box / padding-box / content-box 属性介绍：","categories":[],"tags":[]},{"title":"盒模型，boxsizing","slug":"盒模型，boxsizing","date":"2018-03-29T11:27:43.000Z","updated":"2018-03-29T14:35:44.898Z","comments":true,"path":"2018/03/29/盒模型，boxsizing/","link":"","permalink":"http://songda1005.cn/2018/03/29/盒模型，boxsizing/","excerpt":"","text":"盒模型：标准盒模型是前端布局的概念，把页面中的每一个元素都看做是一个盒子。 盒子的基本属性？ 1、宽高 2、边框 盒子和盒子之间有哪些关系？ 1、邻居 2、盒子里面，还可以装盒子，是嵌套关系 盒模型的组成：内容 + 内边距 + 边框+外边距 box-sizing：怪异盒模型box-sizing 属性用于更改计算元素宽度和高度的默认的 CSS 盒模型，可以使用此属性来模拟不正确支持 CSS 盒子模型规范的浏览器的行为。 12345678/* 关键字 值 */box-sizing: content-box;box-sizing: border-box;/* 全局 值 */box-sizing: inherit;box-sizing: initial;box-sizing: unset; 在 CSS 中，你设置元素的 width 和 height，只会应用到这个元素的内容区。如果这个元素有任何的 border和 padding，绘制到屏幕上时一定要注意这个元素的边框，和内边距，当我们实现响应式时，这点很烦人。 boxsizing 属性就是用来解决这些问题的： content-box 是默认值。如果你设置一个元素为100px，那么这个元素的内容宽度就会有100px，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中 border-box 意识就是告诉浏览器你设置的 border 和 padding 都包含在你的 width 中，也就是说你给这个元素设置 width 100px，你的 border 和 padding 也都会包含在内，内容区的实际宽度会是 width 减去 border + padding 的计算值。大多数情况下这使得我们更容易的去设定一个元素的宽高。 width 和 height 属性包括内容，内边距和边框，但不包括外边距 这里的维度计算为： width = border + padding + 内容的 width， height = border + padding + 内容的 height。","categories":[],"tags":[]},{"title":"css、js放置位置和原因 ","slug":"css、js放置位置和原因","date":"2018-03-26T00:53:35.000Z","updated":"2018-03-26T06:28:05.389Z","comments":true,"path":"2018/03/26/css、js放置位置和原因/","link":"","permalink":"http://songda1005.cn/2018/03/26/css、js放置位置和原因/","excerpt":"","text":"一天，小明正在网上查找资料，项目中遇到的问题需要通过查阅资料来解决，他看到一个标题很有意思，觉得这应该是他要找的答案，于是他就点了进去，结果进入网站后几秒钟的时间，网页还是一片空白，过了好久才加载完成。 为什么会出现这种情况？说到这我们必须了解一下网站加载的整个过程了 首先浏览器在服务器接收HTML代码，然后开始解析HTML 构建DOM树，（从HTML自顶向下进行构建），并且在同时构建渲染树 遇到js文件加载执行，将阻塞DOM树的构建，遇到css文件，将阻塞渲染树的构建 script标签的defer属性：构建DOM树的过程和js文件的加载异步，（并行）进行，但是js执行需要DOM树构建完成之后，script中的async属性，构建DOM树，渲染树的过程和js文件的加载和执行异步，（并行）（进行） 为什么要对css，js的放置位置进行调整？从以上过程可以知道，当js文件放在head中时，浏览器构建DOM树的时候遇到js文件加载会阻塞，也就是说，浏览器不会加载body中的标签，一旦js文件的数量和内容比较大，那么会照成小明刚才遇到的情况，就不会给用户带来十分良好的可视化，在前端工作中，给予用户的可视化回馈十分重要 我们现在十分青睐于用进度条来描述一个过程，而对用户的可视化回馈，就是网页加载的进度条。 对于现如今有着快节奏的人们，如果一个网页打开后在两秒钟内没有反应，或者加载很慢，那么用户就会很不耐烦的关掉它，想当于被直接宣判死刑了。 应该放在哪里？综上所述，script最好放在&lt;/body&gt;标签的前面，因为放在所有body中的标签后面就不会出现网页加载时出现的空白的情况，可以持续给用户提供视觉反馈，会降低错误的发生 而css标签应该放在&lt;head&gt;&lt;/head&gt;之间，因为如果放在&lt;/body&gt;标签的前面，那么DOM树就构建完成了，渲染树才构建，那么当渲染树构建完成，浏览器不得不重新渲染一下页面，这样造成资源浪费，效率也不高，如果放在 &lt;head&gt;&lt;/head&gt;之间，浏览器边构建边渲染，效率也会提高 原文https://segmentfault.com/a/1190000009272434","categories":[],"tags":[]},{"title":"HTML废弃的标签","slug":"HTML废弃的标签","date":"2018-03-18T13:07:20.000Z","updated":"2018-03-18T13:21:06.861Z","comments":true,"path":"2018/03/18/HTML废弃的标签/","link":"","permalink":"http://songda1005.cn/2018/03/18/HTML废弃的标签/","excerpt":"","text":"为什么HTML中有一部分标签会被废弃?因为当前的HTML中的标签只有一个作用, 就是用来添加语义而早期的HTML标签中有一部分标签是没有语义的,有一部分标签是用来修改样式的所以这部分标签就被淘汰了 123456&lt;br&gt; &lt;hr&gt; &lt;font&gt;&lt;b&gt; &lt;u&gt; &lt;i&gt; &lt;s&gt;以上标签都是没有语义的,都是用来修改样式的b(bold) 加粗文本, 没有任何语义的u(underline) 给文本添加下划线, 没有任何语义的i(italic) 将文本倾斜, 没有任何语义的s(strikethourgh) 给文本添加删除线, 没有任何语义的 注意点:以后在企业开发中, 不到万不得已一定不要使用这些被废弃掉的标签如果一定要使用, 一般情况下都是用来作为CSS的钩子来使用 1234strong == bins == uem == idel == s 1234strong语义: 定义重要性强调的文字ins语义(inseted): 定义插入的文字em语义(emphasized): 定义强调的文字del语义(deleted): 定义被删除的文字 1234&lt;b&gt;我是文字&lt;/b&gt;&lt;u&gt;我是文字&lt;/u&gt;&lt;i&gt;我是文字&lt;/i&gt;&lt;s&gt;我是文字&lt;/s&gt; 1234&lt;strong&gt;我是文字&lt;/strong&gt;&lt;ins&gt;我是文字&lt;/ins&gt;&lt;em&gt;我是文字&lt;/em&gt;&lt;del&gt;我是文字&lt;/del&gt; 1234&lt;p class=\"one\"&gt;我是文字&lt;/p&gt;&lt;p class=\"two\"&gt;我是文字&lt;/p&gt;&lt;p class=\"three\"&gt;我是文字&lt;/p&gt;&lt;p class=\"four\"&gt;我是文字&lt;/p&gt;","categories":[],"tags":[]},{"title":"减肥ING","slug":"减肥ING","date":"2018-03-05T00:36:31.000Z","updated":"2018-03-10T11:21:41.707Z","comments":true,"path":"2018/03/05/减肥ING/","link":"","permalink":"http://songda1005.cn/2018/03/05/减肥ING/","excerpt":"","text":"2018-3-5今天是第一天减肥祝我早日成功🎉 8:30分：牛肉三明治 9:53分：一杯凉白开水 11:30分：吃了一块口香糖 12:10分：蔬菜粗粮细作 16:30分：一杯开水 18:20分：一个苹果🍎 2018-3-6今天是减肥的第二天，昨天忍着饥饿睡着了，才知道减肥不容易啊，总之加油吧！ 8:40分：麦片搭配酸奶🥛 10:00分：一杯水 12:15分：两个素馅包子，一碗小米粥 14:30分：一杯水 17:20分：还是一杯水 18:10分：切后的什锦水果(🍓🍉🍎🍌🍊)放在一个小盒里 2018-3-7今天是减肥的第三天，来吧，加油 7:30分：一个煎鸡蛋🍳，和麦片酸奶，一杯水 9:30分：一杯水 11:10分：一杯水 12:10分：素馅混沌，一个饼 13:10分：一杯水 15:00分：一杯水 17:30分：一杯水 18:10分：一根黄瓜🥒 2018-3-8今天是减肥的第四天，来吧，加油 9:00分：一杯水 10:10分：一杯水 12:10分：一个馒头，和清炒土豆丝🥔 14:20分：一杯水","categories":[],"tags":[{"name":"减肥","slug":"减肥","permalink":"http://songda1005.cn/tags/减肥/"}]},{"title":"JavaScritp变量--匈牙利命名法","slug":"JavaScritp变量-匈牙利命名法","date":"2018-02-12T05:47:40.000Z","updated":"2018-02-12T07:01:39.318Z","comments":true,"path":"2018/02/12/JavaScritp变量-匈牙利命名法/","link":"","permalink":"http://songda1005.cn/2018/02/12/JavaScritp变量-匈牙利命名法/","excerpt":"","text":"JavaScript变量–匈牙利命名法 匈牙利命名法语法：变量名＝类型＋对象描述类型指变量的类型对象描述指对象名字全称或名字的一部分，要求有明确含义，命名要容易记忆容易理解。提示: 虽然JavaScript变量表面上没有类型，但是JavaScript内部还是会为变量赋予相应的类型。 提示: 匈牙利命名法是一位微软程序员发明的，多数的C,C++程序都使用此命名法。 JavaScript变量匈牙利命名类型 JavaScript变量起名类型 变量命名前缀 Array 数组 a Float 浮点 l Function 函数 f Integer(int) 整型 n Object 对象 o Regular Expression 正则 r String 字符串 s JavaScript变量名匈牙利命名法示例 var sWebURL=”www.jb51.net”;从变量的名字可以看出s代表字符串WebURL是网址。var nCheckCount=5;从变量的名字可以看出n代表Integer(整型)，CheckCount代表某种数量。var oDiv1=document.getElementById(‘box1’);从变量的名字可以看出o代表Object(对象)。 使用匈牙利命名法非常简单直观，方便判断变量的类型，而且方便程序的阅读与维护。 本文借鉴于：http://www.cnblogs.com/woohblog/archive/2013/01/02/2842457.html","categories":[],"tags":[]},{"title":"HTML5 canvas介绍及应用","slug":"HTML5-canvas介绍及应用","date":"2018-02-12T04:01:08.000Z","updated":"2018-02-12T04:01:51.052Z","comments":true,"path":"2018/02/12/HTML5-canvas介绍及应用/","link":"","permalink":"http://songda1005.cn/2018/02/12/HTML5-canvas介绍及应用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"react-webpack简单配置","slug":"react-webpack简单配置","date":"2018-02-07T14:38:47.000Z","updated":"2018-02-08T08:57:08.357Z","comments":true,"path":"2018/02/07/react-webpack简单配置/","link":"","permalink":"http://songda1005.cn/2018/02/07/react-webpack简单配置/","excerpt":"","text":"首先我们先简单的构建一下项目的目录名字就叫webpack 文件夹，然后我们进到这个文件夹，然后在这里面我们要构建一个从零开始的一个项目结构的目录首先我们现在这个文件夹下面执行一个命令，就是yarn,这个东西和npm差不多，听说你下载的速度比npm快，但是我也没怎么发现，这个东西是facebook推出的，那我来执行这段命令 $ npm i -g yarn 然后安装完之后会有一段提示，说不让你这么安装，说当前的环境有问题，因为是通过npm装的它，如果node出了问题，这个东西就不能用了，但是这个东西没什么问题，我也去查了，证明了这件事，然后我们初始化我们的文件夹，之前是npm init -y,这个也跟它差不多 $ yarn init -y 这时我们的目录会多一个叫package.json的文件 然后我们在根目录创建一个src文件夹，在这个文件夹里创建一个index.js，这个文件是我们的入口文件，然后我们回到根目录来安装我们的webpack $ yarn add webpack —dev —dev这个是开发的依赖 然后我们在全局装一下webpack $ npm i -g webpack 然后我们在根目录创建一个webpack的配置文件叫webpack.config.js,这里面是webpack的主要配置文件,现在我们的目录结构是这样的 然后我们开始配置webpack.config.js 1234567891011// webpack.config.js 第一步const path = require('path') // 引入pathmodule.exports = &#123; // 入口文件 entry:'./src/index.js', // 出口 里面有两个东西 一个是path路径 一个是filename output:&#123; path:path.join(__dirname,'dist'), filename:'build.js' &#125;&#125; 在终端执行 $ webpack 这时我们根目录会生成一个dist文件，里面有一个build.js，这里面是webpack帮你生成的一些内容，这是webpack本身的一些函数，里面的每一行大家都应该知道是什么意思，在这里就不去讲了，现在我们编译的过程已经搞定了，然后我们进入src里面的index.js，这里面我们写一下我们React.js的代码 123import React from 'react';import ReactDOM from 'react-dom';render(&lt;h1&gt;React Hello&lt;/h1&gt;,document.getElementById('root')) 然后执行webpack webpack 会有报错 123456ERROR in ./src/index.jsModule parse failed: Unexpected token (3:7)You may need an appropriate loader to handle this file type.| import React from 'react';| import ReactDOM from 'react-dom';| render(&lt;h1&gt;React Hello&lt;/h1&gt;,document.getElementById('root')) 这时候我们还没有react,和react-dom,它不认识jsx语法然后安装 $ yarn add react react-dom 123import React from 'react';import ReactDOM from 'react-dom';render() //里面先不放 在执行webpack 先在还不识别jsx语法 我们少了一些东西就是babel 123&gt;$ yarn add @babel/preset-react @babel/preset-env @babel/core babel-loader@8.0.0-beta.0 --dev&gt;&gt; 创建.babelrc 文件，加入如下代码: 123&#123; \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"]&#125; 这里是babel的配置这是一个转译的过程，让浏览器能认识 然后我们新建一个index.html文件看看效果 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script src=\"./dist/build.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这个我们的文字就出来了，但是我们是手动引入的&lt;script src=&quot;./dist/build.js&quot;&gt;&lt;/script&gt;这个文件，我们需要让它自动引入，那我们就得在webpack.config.js里面再配置些东西 先下载一个插件,这个插件是自动导入生成的文件 $ yarn add html-webpack-plugin –dev 现在看看我们的配置文件是什么样子 1234567891011121314151617181920212223242526272829303132const path = require('path') // 引入pathconst HTMLWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; // 入口文件 entry:'./src/index.js', // 出口 里面有两个东西 一个是path路径 一个是filename output:&#123; path:path.join(__dirname,'dist'), filename:'build.js' &#125;, module:&#123; // loaders 这是一个数组类型，数组中包含对象，你可以放很多对象，分别来处理各种任务 loaders:[ &#123; test:/\\.js$/, // 用来匹配所有的js文件，这里面写的是一个正则 loader:'babel-loader', exclude:/node_modules/ // 排除 就是除了node_modules 之外 &#125; ] &#125;, plugins:[ // 这个插件是直接把生成的文件直接引用进去，自动引入js 是一个数组类型 // 默认情况下是有参数的 new HTMLWebpackPlugin(&#123; // 模版 template:'./index.html', filename:'index.html', title:'首页', inject:'body' &#125;) ]&#125; 配置完之后我们把之前引入的&lt;script src=&quot;./dist/build.js&quot;&gt;&lt;/script&gt;删除调，在执行命令 $ Webpack 这时我们的dist文件里就有个index.html文件了 最后一步就是相当于我们启动一个服务，首先先执行一下命令，这个命令能让我们更方便的执行 $ yarn add webpack-dev-server —dev 然后在我们的package.json,下加一段话 12345678910111213141516171819202122&#123; \"name\": \"webpack_text\", \"version\": \"1.0.0\", \"main\": \"index.js\", \"license\": \"MIT\", \"scripts\": &#123;// 加的就是这段话 \"start\": \"webpack-dev-server\" &#125;, \"devDependencies\": &#123; \"@babel/core\": \"^7.0.0-beta.39\", \"@babel/preset-env\": \"^7.0.0-beta.39\", \"@babel/preset-react\": \"^7.0.0-beta.39\", \"babel-loader\": \"8.0.0-beta.0\", \"html-webpack-plugin\": \"^2.30.1\", \"webpack\": \"^3.10.0\", \"webpack-dev-server\": \"^2.11.1\" &#125;, \"dependencies\": &#123; \"react\": \"^16.2.0\", \"react-dom\": \"^16.2.0\" &#125;&#125; 然后我们运行命令 $ yarn start 执行完之后，它会告诉我们，我们的项目现在已经运行在http://localhost:8080/，然后我们就直接输入地址http://localhost:8080/，就行了，自动的你对文件进行修改它就会发生变化，实时更新，是不是很好","categories":[],"tags":[]},{"title":"javascript代码规范","slug":"javascript代码规范","date":"2018-02-05T03:25:02.000Z","updated":"2018-02-05T04:00:25.024Z","comments":true,"path":"2018/02/05/javascript代码规范/","link":"","permalink":"http://songda1005.cn/2018/02/05/javascript代码规范/","excerpt":"","text":"运算符、操作符左右两边加空格 语句结尾加分号( ); 函数定义-&gt; function空格，sum空格()，参数列表空格{} 1234// 正确写法function sum () &#123;// 代码 &#125; 箭头函数 12345678// 正确写法let sum = (a，b) =&gt; &#123; return a + b ;&#125;;// 单参数写法let square = number =&gt; &#123; return number * number;&#125;; TabSize定义为2个空格 统一字符串使用双引号&quot;&quot;,多行文本使用模版字符串`` 涉及到判断是否一致，全部使用 ===和!== 代码段中多于行删除 代码段与代码段之间加空行 注释 单行注释，//后加空格 123// 我是注释// 我是注释// 我是注释 多行注释*后注释前，需要加空格 12345/* * 我是多行注释 * 我是多行注释 * 我是多行注释 */ ​","categories":[],"tags":[]},{"title":"meta标签","slug":"meta标签","date":"2018-02-04T12:23:35.000Z","updated":"2018-02-05T02:49:57.450Z","comments":true,"path":"2018/02/04/meta标签/","link":"","permalink":"http://songda1005.cn/2018/02/04/meta标签/","excerpt":"","text":"什么是meta标签根据w3c定义，meta元素是可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。 meta标签位于文档的头部，不包含任何内容。 标签的属性定义了与文档相关联的名称/值对。 简单来说，meta标签是给搜索引擎看的标签，对于seo有着举足轻重的作用。 常用的meta标签descriptionmeta description，被认为是最有用的meta标签，是网站的简介信息。 1&lt;meta name=\"description\" content=\"description of your site\"/&gt; 这个标签在搜索引擎中的占比很高，所以是seo的主要标签，随着各类网站seo的滥用和搜索引擎的算法变更，目前该标签作用逐渐变弱。不过一般推荐还是设置一下，content控制在100个字符以内比较好。 keywordsmeta keywords，慎用的标签。 1&lt;meta name=\"keywords\" content=\"keyword1 keyword2\"/&gt; 曾经是seo重点优化标签，现在由于滥用，基本不再是搜索引擎搜索的标签，而且被发现滥用可能导致搜索引擎把你权重下降，得不偿失。 title严格意义上来说，title不算是meta标签。不过title标签对于搜索引擎的占比很高，所以把它作为meta标签的一类。 1&lt;title&gt;Title Name&lt;/title&gt; 建议控制title在50个字符以内。 charsetmeta charset，默认字符编码。 1&lt;meta charset=\"utf-8\"/&gt; 建议采用这种简写方式，向后兼容。 Compatible兼容标签，针对不同浏览器。 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"/&gt; 我的简单优化(带注释)12345678910111213141516&lt;meta charset=\"utf-8\" /&gt; // 字符编码&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; // 兼容适配&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; // 设备适配&lt;meta name=\"description\" content=\"前端技术博客，关注代码的点点滴滴\" /&gt; // 简介&lt;meta name=\"generator\" content=\"Ghost 0.78\" /&gt; // 生产工具&lt;meta name=\"author\" content=\"宋达\" /&gt; // 作者&lt;meta name=\"robots\" content=\"index,follow\" /&gt; // 搜索优化，下同&lt;meta name=\"google\" content=\"index,follow\" /&gt;&lt;meta name=\"googlebot\" content=\"index,follow\" /&gt;&lt;meta name=\"verify\" content=\"index,follow\" /&gt;&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt; // webapp全屏&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" /&gt; // apple状态栏颜色&lt;meta name=\"format-detection\" content=\"telephone=no, email=no\" /&gt; // 禁止电话邮件自动识别&lt;meta name=\"HandheldFriendly\" content=\"true\" /&gt; // 移动设备优化，针对不支持viewpoint设备&lt;meta name=\"MobileOptimized\" content=\"320\" /&gt; // 微软旧浏览器适配&lt;title&gt;&#123;&#123;meta_title&#125;&#125; - my-的前端博客&lt;/title&gt; // title 本文借鉴于：https://excaliburhan.com/post/seo-and-optimize-meta.html","categories":[],"tags":[]},{"title":"HTML5 data-* 自定义属性","slug":"HTML5-data-自定义属性","date":"2018-02-04T11:58:07.000Z","updated":"2018-02-12T06:53:27.894Z","comments":true,"path":"2018/02/04/HTML5-data-自定义属性/","link":"","permalink":"http://songda1005.cn/2018/02/04/HTML5-data-自定义属性/","excerpt":"","text":"data-* 属性是 HTML 5 的新特性，允许用户在 DOM 中存储自定义信息。 以前，需要存储含有特定含义的信息通常是通过 class 完成的，但这并不是 class 本来的用途。现在，利用 HTML 5，可以为元素添加data-*属性，从而存储自定义信息。其中*是可以自定义的部分。例如： 1&lt;article id=\"tu\" data-category=\"Web Development\" data-author=\"1\"&gt; ... &lt;/article&gt; 通过 JavaScript 访问通过 JavaScript 访问自定义的信息有两种方式：getAttribute()和dataset。 getAttribute 方法这就是经典的取得一个元素属性的方式，和以前一样。 1document.getElementById('tu').getAttribute('data-category');// \"Web Development\" dataset 方法这是 HTML 5 新增的方法，可以更方便的读取所有的 data 信息。 1234var article = document.getElementById('tu');var data = article.dataset;alert(data.category); // \"Web Development\"alert(data.author); // 1 通过 jQuery 访问jQuery 也提供了专门的data方法来访问这些信息： 1$(\"#tu\").data('category'); // \"Web Development\" 通过 CSS 访问使用 attr123article::before &#123; content: attr(data-category);&#125; 使用属性选择器123article[data-author='1'] &#123; border-width: 1px;&#125; 修改信息在引入 jQuery 之前，使用 JavaScript 修改自定义信息也非常容易，两种方式都可以： 123var a = document.getElementById('tu');a.dataset.category = \"Uncategorized\";a.setAttribute(\"data-category\", \"Uncategorized\"); 然而如果你用 jQuery 的data方法进行修改： 1$(\"#tu\").data(\"category\", \"Uncategorized\"); 会发现 HTML 代码并没有改动，同时使用dataset等标准 JavaScript 读出来的数据也是修改之前的数据。类似，如果先用 jQuery 读取一次，然后再用标准 JavaScript 修改，再用 jQuery 读取第二次，则发现读取的数据仍是修改之前的数据。可是如果没有经过 jQuery 读取直接用标准 JavaScript 修改，这时再用 jQuery 读取，读到的就是新数据了。 这是怎么回事儿？ jQuery 的文档对此有所说明： The data- attributes are pulled in the first time the data property is accessed and then are no longer accessed or mutated (all data values are then stored internally in jQuery). 原来，标准 JavaScript 直接对 DOM 进行读写（和我们设想的一致），但是 jQuery 不同。jQuery 的内部也维护着一份这些 data 数据。当第一次使用 jQuery 读取时，数据被从 DOM 读到jQuery.cache保存起来，以后使用 jQuery 修改时，修改的是内部维护的这个数据，同时再次读取也会从 jQuery 内部而非 DOM 读取数据。 因此，最好的办法是，要么一直用标准 JavaScript，要么一直用 jQuery。不要两者混用就好了。jQuery 如此设计的初衷就是为了减少 DOM 读写从而提高性能。 总结一个最大的好处是我们可以把所有自定义属性在dataset对象中统一管理，遍历啊神马的都哦很方便，而不至于零零散散了，所以用用还是不错的。 浏览器兼容性比较不好的消息就是data-*的浏览器兼容性情况十分不乐观 Chrome 8+ Firefox 6.0+ Opera 11.10+ Safari 6+","categories":[],"tags":[]},{"title":"html和xhtml和xml的区别","slug":"html和xhtml和xml的区别","date":"2018-01-31T01:23:57.000Z","updated":"2018-01-31T04:01:59.123Z","comments":true,"path":"2018/01/31/html和xhtml和xml的区别/","link":"","permalink":"http://songda1005.cn/2018/01/31/html和xhtml和xml的区别/","excerpt":"","text":"1、html即是超文本标记语言（Hyper Text Markup Language），是最早写网页的语言，但是由于时间早，规范不是很好，大小写混写且编码不规范； 2、xhtml即是升级版的html（Extensible Hyper Text Markup Language），对html进行了规范，编码更加严谨纯洁，也是一种过渡语言，html向xml过渡的语言； 3、xml即时可扩展标记语言（Extensible Markup Language），是一种跨平台语言，编码更自由，可以自由创建标签。 4、网页编码从html&gt;&gt;xhtml&gt;&gt;xml这个过程发展。 html和xhtml和xml的区别可以参考这个网页：http://www.dreamdu.com/xhtml/html_xhtml/ 1、xhtml对比与html，xhtml文档具有良好完整的排版，体现在两方面：a、元素必须要有结束标签；b、元素必须嵌套； 2、对于html的元素和属性，xhtml必须小写，因为xml是严格区分大小写的，和是不同的标签； 3、xhtml的属性值必须在引号之中； 4、xhtml不支持属性最小化，什么是属性最小化了？ 1234567正确:非最小化属性(unminimized attributes) &lt;input checked=\"checked\"&gt;不正确:最小化属性(minimized attributes) &lt;input checked&gt; 5、 在xhtml中，name属性是不赞成使用的，在以后的版本中将被删除。 总结：再说说为什么网页编码要从html&gt;&gt;xhtml&gt;&gt;xml这么发展？话说早起的网页使用html语言编写的，但是它拥有三个严重的缺点： 1、编码不规范，结构混乱臃肿，需要智能的终端才能很好的显示； 2、表现和结构混乱，不利于开发和维护； 3、不能使用更多的网络设备，比如手机、PDA等; 因此HTML需要发展才能解决这个问题，于是W3C又制定了XHTML，XHTML是HTML向XML 过度的一个桥梁。而xml是web发展的趋势。 本文借鉴于:http://www.cnblogs.com/fredshare/archive/2011/11/10/2244308.html","categories":[],"tags":[]},{"title":"React中state和props分别是什么？","slug":"React中state和props分别是什么？","date":"2018-01-30T12:43:59.000Z","updated":"2018-01-31T00:50:18.621Z","comments":true,"path":"2018/01/30/React中state和props分别是什么？/","link":"","permalink":"http://songda1005.cn/2018/01/30/React中state和props分别是什么？/","excerpt":"","text":"整理一下React中关于state和props的知识点。 在任何应用中，数据都是必不可少的。我们需要直接的改变页面上一块的区域来使得视图的刷新，或者间接地改变其他地方的数据。React的数据是自顶向下单向流动的，即从父组件到子组件中，组件的数据存储在props和state中，这两个属性有啥子区别呢？ propsReact的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件。 组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是props，所以可以把props理解为从外部传入组件内部的数据。由于React是单向数据流，所以props基本上也就是从服父级组件向子组件传递的数据。 用法假设我们现在需要实现一个列表，根据React组件化思想，我们可以把列表中的行当做一个组件，也就是有这样两个组件：&lt;ItemList/&gt;和&lt;Item/&gt;。 先看看&lt;ItemList/&gt; 123456789import Item from &quot;./item&quot;;export default class ItemList extends React.Component&#123; const itemList = data.map(item =&gt; &lt;Item item=item /&gt;); render()&#123; return ( &#123;itemList&#125; ) &#125;&#125; 列表的数据我们就暂时先假设是放在一个data变量中，然后通过map函数返回一个每一项都是&lt;Item item=&#39;数据&#39;/&gt;的数组，也就是说这里其实包含了data.length个&lt;Item/&gt;组件，数据通过在组件上自定义一个参数传递。当然，这里想传递几个自定义参数都可以。 在&lt;Item /&gt;中是这样的： 1234567export default class Item extends React.Component&#123; render()&#123; return ( &lt;li&gt;&#123;this.props.item&#125;&lt;/li&gt; ) &#125;&#125; 在render函数中可以看出，组件内部是使用this.props来获取传递到该组件的所有数据，它是一个对象，包含了所有你对这个组件的配置，现在只包含了一个item属性，所以通过this.props.item来获取即可。 只读性props经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的props是只读的，不可改变的。如果props在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的props传入组件中。 默认参数在组件中，我们最好为props中的参数设置一个defaultProps，并且制定它的类型。比如，这样： 1234567Item.defaultProps = &#123; item: 'Hello Props',&#125;;Item.propTypes = &#123; item: PropTypes.string,&#125;; 关于propTypes，可以声明为以下几种类型： 1234567optionalArray: PropTypes.array,optionalBool: PropTypes.bool,optionalFunc: PropTypes.func,optionalNumber: PropTypes.number,optionalObject: PropTypes.object,optionalString: PropTypes.string,optionalSymbol: PropTypes.symbol, 注意，bool和func是简写。 这些知识基础数据类型，还有一些复杂的，附上链接：https://doc.react-china.org/ 总结props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。 statestate是什么呢？ State is similar to props, but it is private and fully controlled by the component. 一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是props，而数据状态就是state。 用法12345678910111213export default class ItemList extends React.Component&#123; constructor()&#123; super(); this.state = &#123; itemList:&apos;一些数据&apos;, &#125; &#125; render()&#123; return ( &#123;this.state.itemList&#125; ) &#125;&#125; 首先，在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。 setStatestate不同于props的一点是，state是可以被改变的。不过，不可以直接通过this.state=的方式来修改，而需要通过this.setState()方法来修改state。 比如，我们经常会通过异步操作来获取数据，我们需要在didMount阶段来执行异步操作： 1234567componentDidMount()&#123; fetch(&apos;url&apos;) .then(response =&gt; response.json()) .then((data) =&gt; &#123; this.setState(&#123;itemList:item&#125;); &#125;&#125; 当数据获取完成后，通过this.setState来修改数据状态。 当我们调用this.setState方法时，React会更新组件的数据状态state，并且重新调用render方法，也就是会对组件进行重新渲染。 注意：通过this.state=来初始化state，使用this.setState来修改state，constructor是唯一能够初始化的地方。 123456789101112export default class ItemList extends React.Component&#123; constructor()&#123; super(); this.state = &#123; name:&apos;axuebin&apos;, age:25, &#125; &#125; componentDidMount()&#123; this.setState(&#123;age:18&#125;) &#125;&#125; 在执行完setState之后的state应该是{name:&#39;axuebin&#39;,age:18}。 setState还可以接受第二个参数，它是一个函数，会在setState调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成： 123this.setState(&#123; name:&apos;xb&apos;&#125;,()=&gt;console.log(&apos;setState finished&apos;)) 总结state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。 区别 state是组件自己管理数据，控制自己的状态，可变； props是外部传入的数据参数，不可变; 没有state的叫做无状态组件，有state的叫做有状态组件 多用props，少用state。也就是多写无状态组件。 本文借鉴于：https://segmentfault.com/a/1190000011184076","categories":[],"tags":[]},{"title":"React中元素与组件的区别,和组件有几种类型","slug":"React中元素与组件的区别","date":"2018-01-30T11:42:53.000Z","updated":"2018-01-30T12:41:19.834Z","comments":true,"path":"2018/01/30/React中元素与组件的区别/","link":"","permalink":"http://songda1005.cn/2018/01/30/React中元素与组件的区别/","excerpt":"","text":"在初学 React 的时候，分不清 React 组件和 React 元素，着实踩了一些坑。搞清楚 React 中什么是组件，什么是元素，既可以理清楚概念，也可以让你避免一些不必要的错误。 React 元素React 元素（React element），它是 React 中最小基本单位，我们可以使用 JSX 语法轻松地创建一个 React 元素: 1const element = &lt;div className='element'&gt;I'm element&lt;/div&gt; React 元素不是真实的 DOM 元素，它仅仅是 js 的普通对象（plain objects），所以也没办法直接调用 DOM 原生的 API。上面的 JSX 转译后的对象大概是这样的： 1234567891011&#123; _context: Object, _owner: null, key: null, props: &#123; className: 'element'， children: 'I‘m element' &#125;, ref: null, type: \"div\"&#125; 只有在这个元素渲染被完成后，才能通过选择器的方式获取它对应的 DOM 元素。不过，按照 React 有限状态机的设计思想，应该使用状态和属性来表述组件，要尽量避免 DOM 操作，即便要进行 DOM 操作，也应该使用 React 提供的接口ref和getDOMNode()。一般使用 React 提供的接口就足以应付需要 DOM 操作的场景了，因此像 jQuery 强大的选择器在 React 中几乎没有用武之地了。 除了使用 JSX 语法，我们还可以使用 React.createElement() 和 React.cloneElement() 来构建 React 元素。 React.createElement()JSX 语法就是用React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。 12345React.createElement( type, [props], [...children]) React.cloneElement()React.cloneElement()与React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而就的子元素奖杯替换。 12345React.cloneElement( element, [props], [...children]) React 组件React 中有三种构建组件的方式。React.createClass()、ES6 class和无状态函数。 React.createClass()React.createClass()是三种方式中最早，兼容性最好的方法。在0.14版本前官方指定的组件写法。 12345var Greeting = React.createClass(&#123; render : function()&#123; return &lt;h1&gt;Hello,&#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125;); ES6 classES6 class是目前官方推荐的使用方式，它使用了ES6标准语法来构建，但它的实现仍是调用React.createClass()来实现了，ES6 class的生命周期和自动绑定方式与React.createClass()略有不同。 12345class Greeting extends React.Component&#123; render:function()&#123; return &lt;h1&gt;Hello,&#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125; 无状态函数无状态函数是使用函数构建的无状态组件，无状态组件传入props和context两个参数，它没有state，除了render()，没有其它生命周期方法。 123function Greeting (props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; React.createClass()和ES6 class构建的组件的数据结构是类，无状态组件数据结构是函数，它们在 React 被视为是一样的。 元素与组件的区别元素是一个纯的JSON对象，用于描述你想通过DOM节点或者其他组件在荧屏上展示的内容。元素可以在他们的参数里面包含其他元素。创建一个React元素代价非常小。一个元素一旦被创建，将不可更改。 一个组件可以用几种不同的方式去声明。可以是一个带有render()方法的类。作为另外一种选择，在简单的情况下，组件可以被定义为一个函数。在两种方式下，组件都是被传入的参数作为输入内容，以返回的元素作为输出内容。 如果有一个组件被调用，传入了一些参数作为输入，那是因为有一某个父组件返回了一个带有这个组件的type以及这些参数(到React上)。这就是为什么大家都认为参数流动方式只有一种：从父组件到子组件。 实例就是你在组件上调用this时候得到的东西，它对本地状态存储以及对响应生命周期事件非常有用。 函数组件根本没有实例，类组件拥有实例，但是你从来都不需要去直接创建一个组件实例——React会帮你管理好它。 最后，想要创建元素，使用React.createElement(),JSX或者一个元素工厂工具。不要在实际代码上把元素写成纯JSON对象——仅需要知道他们在React机制下面以纯JSON对象存在就好。 本文借鉴于https://segmentfault.com/a/1190000008587988","categories":[],"tags":[]},{"title":"EJS模版","slug":"EJS模版","date":"2018-01-30T00:42:00.000Z","updated":"2018-01-30T11:36:33.277Z","comments":true,"path":"2018/01/30/EJS模版/","link":"","permalink":"http://songda1005.cn/2018/01/30/EJS模版/","excerpt":"","text":"一、EJS模版概念E”是“有效的，EJS是一个简单高效的模版语言，通过数据和模版，可以让您使用普通的JavaScript生成HTML标记","categories":[],"tags":[]},{"title":"grunt的安装与介绍","slug":"grunt的安装与介绍","date":"2018-01-26T06:12:29.000Z","updated":"2018-03-30T15:29:36.215Z","comments":true,"path":"2018/01/26/grunt的安装与介绍/","link":"","permalink":"http://songda1005.cn/2018/01/26/grunt的安装与介绍/","excerpt":"","text":"Grunt安装及使用介绍Grunt都能做什么，自动化，减少像压缩，编译，单元测试，代码效验，打包，管理，优化，多余的东西干掉，这些重复且无业务关联的工作，我们做的越少，就可以留出更多的精力，来专注与我们的业务代码，那为什么我们选择grunt呢，是因为grunt的生态实在是在强大了，只要你能想到的任务，基本上都可以找到grunt的相关的自动化插件，并且grunt的生态一直在持续增长，我们不能给grunt全世界，但是grunt的全世界都给了我们 首先我们先创建一个文件夹名字叫grunt-test 官方站点：http://gruntjs.com/ 然后进入到这个文件夹，在这个文件夹中执行 npm init 然后会提示你是否会创建这一个文件，然后会让我们输入一些东西，比如，版本啊，描述啊，作者啊，关键词啊，等等，我们就默认就行了，最后我们目录下就会生成一个package.json的文件 1234567891011&#123; \"name\": \"grunt-test\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\"&#125; 这样就生成了一个package.json的文件，现在有这个文件了，我们需要在安装执行grunt需要的命令行，就是 npm i -g grunt-cli 注意Mac OS linux 命令前面需要加sudo的语句 然后我们执行一段命令,把真正的grunt安装到我们的项目里面来 $ npm i grunt –save-dev 安装完之后你会发现你项目的目录里会多了一个文件，叫node_modules的文件,里面有很多第三方的库，来支持grunt的运转，然后回到你的package.json,文件里会发现多了点东西 1234567891011121314&#123; \"name\": \"grunt-test\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"grunt\": \"^1.0.1\" &#125;&#125; 多了依赖，就是我们项目用的’grunt’:’^1.0.1’,然后我们在执行grunt $ grunt 不能找到你的Gruntfile Fatal error: Unable to find Gruntfile. 又报错了，说找不到你的Gruntfile文件，Gruntfile文件是什么呢，就是grunt写任务的文件夹，grunt所有的配置都在这个文件里面写，那我们就在项目的根目录创建一个Gruntfile.js文件，创建完之后现在项目的结构是这样的 12345|--grunt-test|--|--node_modules|--|--Gruntfile.js|--|--package.json|--|--package-lock.json 到现在为止我们的grunt就算是安装完了，然后在执行命令 $ grunt 会提示这一句话 123Warning: Task \"default\" not found. Use --force to continue.Aborted due to warnings. 说没有找到”default”的Task,那么怎么实现Task的执行任务呢 首先我们今天就来讲讲js文件压缩，和css文件合并压缩，先准备一个js文件，和css文件，里面有一个你需要压缩的js文件，和css文件，在准备一个空文件夹名字叫做dist文件夹，这个文件夹是用来装你压缩过的文件，让我们看看现在的目录结构是什么样子的 现在我们开始配置我们Gruntfile文件里的内容了，内容是这样的: 123456789101112131415161718192021222324252627282930313233//这个约定了Grunt所有插件在这里配置。 module.exports = function (grunt) &#123;//这是Node.js的典型写法，使用exports公开API grunt.initConfig(&#123; //定义各种模块的参数，每一个成员项对应一个同名模块,项目配置以及任务配置。 pkg:grunt.file.readJSON('package.json'),//获取依赖关系提供你需要的插件的版本和名称 uglify:&#123;//压缩js代码 options: &#123;//这里是uglify任务的配置信息 banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(\"yyyy-mm-dd\") %&gt; */\\n' &#125;, build:&#123; //源文件 files: &#123; 'dist/index.min.js':'js/index.js' &#125; &#125; &#125;, cssmin:&#123;//Css压缩合并 options:&#123; // keepSpecialComments:0 &#125;, compress:&#123; files:&#123; 'dist/default.min.css':[ 'css/saibaiwei.css', 'css/saibaiwei1.css' ] &#125; &#125; &#125; &#125;); grunt.loadNpmTasks('grunt-contrib-uglify');//告诉grunt我们使用的模块 grunt.loadNpmTasks('grunt-contrib-cssmin'); grunt.registerTask('yasuo',['uglify','cssmin'])//定义具体的任务。 // 第一个参数为任务名，第二个参数是一个数组， 表示该任务需要依次使用的模块。 &#125;; 好了朋友们现在配置文件已经写好了，那我们来执行任务吧，首先我们应该安装js压缩，还有css压缩合并需要的插件 js压缩插件 $ npm i grunt-contrib-uglify css压缩合并插件 $ npm i grunt-contrib-cssmin 安装完之后我们就可以执行了，我们需要用grunt命令来执行 grunt.registerTask(&#39;yasuo&#39;,[&#39;uglify&#39;,&#39;cssmin&#39;])里的第一个参数 $ grunt yasuo 命令执行之后你的dist文件里会多出两个压缩的文件，让我们来看看 总结：grunt是最早的，打包工工具，现在有很多打包工具的，比如gulp,webpack，这些都是前端是实用的打包工具，但是随着这些打包工具的出现，grunt也大不如以前了，grunt相当于打包的鼻祖了 1.其实grunt配置很简单，Gruntfile文件是js格式的，比较贴近前端的知识2.Grunt还有很多插件等着我们去使用3.每个人的具体需求不一样，可以按自己的习惯合理配置，组合成最适合自己项目的自动化工作流。","categories":[],"tags":[]},{"title":"HTML标准模式，和怪异模式","slug":"HTML标准模式，和怪异模式","date":"2018-01-15T12:49:20.000Z","updated":"2018-01-15T13:13:02.731Z","comments":true,"path":"2018/01/15/HTML标准模式，和怪异模式/","link":"","permalink":"http://songda1005.cn/2018/01/15/HTML标准模式，和怪异模式/","excerpt":"","text":"一、什么是标准模式和怪异模式在实现html和css标准化之前，各个浏览器对html和css的解析各有不同，甚至是同一个浏览器的不同版本渲染方式也不同（比如IE6和IE7）。在W3C制定标准之后，浏览器既要按照标准去实现HTML和CSS的支持，又要保证能够兼容以前的非标准的旧网页，于是就有了现在所说的标准模式（严格模式）和兼容模式（怪异模式）。 二、浏览器如何确定渲染模式呢在编写HTML文档时，一般都会在文档的开头，html标签之前声明文档类型：DOCTYPE，当浏览器在解析html文档时，若遇到正确的文档声明，则启用标准模式，按照标准来解析和渲染文档。而对于旧的html文档，或没有DOCTYPE声明的文档，则按照怪异模式来解析文档。html5的文档声明方式：&lt;!DOCTYPE HTML&gt; 。 三、标准模式和怪异模式的区别？1、width不同，在标准模式中：width是内容（content）宽度，元素真正的宽度是外边距、内边距、边框宽度的和，即元素宽度 = margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right，在怪异模式中：width则是元素的实际宽度，width = border-left-width + padding-left+ 内容(content)宽度 + padding-right + border-right-width。 2、内联元素的尺寸标准模式中，给span等行内元素设置width和height都不会生效，而在怪异模式下，却会生效。 3、可设置百分比的高度在标准模式下，一个元素的高度由其包含的内容content决定，如果父元素没有设置高度，子元素设置一个百分比高度是无效的。 4、用margin : 0 auto设置水平居中在标准模式下可以使元素水平居中，但是在怪异模式下，无效，可以用text-align : center;来实现居中。 5、怪异模式下设置图片的padding会失效 6、怪异模式下table中的字体属性不能继承上层的设置 7、元素溢出的处理，标准模式下，overflow默认去visible，在怪异模式下，溢出会被当做扩展box来对待，溢出不会裁减，元素框自动调整大小，能够包含溢出内容。","categories":[],"tags":[]},{"title":"HTML5新特性，语义化","slug":"HTML5新特性，语义化","date":"2018-01-13T07:49:00.000Z","updated":"2018-02-12T06:51:55.194Z","comments":true,"path":"2018/01/13/HTML5新特性，语义化/","link":"","permalink":"http://songda1005.cn/2018/01/13/HTML5新特性，语义化/","excerpt":"","text":"一、为什么HTML5要引入新语义标签在HTML5之前采用HTML+CSS文档结构写法，但是这样的布局方式不仅使我们的文档结构不够清晰，而且不利于搜索引擎爬虫对我们页面的爬取。为了解决上述缺点，HTML5新增了很多新的语义化标签。 二、引入语义化标签的优点引入语义化标签的好处主要有下列三点： 比&lt;div&gt;标签有更加丰富的含义，方便开发与维护 搜索引擎能更方便的识别页面的每个部分 方便其他设备解析（如移动设备、盲人阅读器等） 三、标签详解所谓语义化标签就是一种我们仅通过标签名就能判断出该标签内容的语义的标签。下面将介绍&lt;article&gt; &lt;section&gt; &lt;nav&gt; &lt;aside&gt;、&lt;header&gt; &lt;footer&gt;等HTML5新增的语义化区块标签。 （一） header 通常被放置在页面或者页面中某个区块元素的顶部，包含整个页面或者区块的标题、简介等信息，起到引导与导航的作用。 我们不但可以放置页面或者页面中某个区块的标题，还可以放置搜索表单、logo图片等元素，按照最新的W3C标准，我们还可以放置&lt;nav&gt;导航栏。 下面是一个使用该标签的网站头部实例： 1234&lt;header&gt; &lt;img src=&quot;images/logo.png&quot; alt=&quot;**科技&quot; /&gt; &lt;h1&gt;**信息科技有限公司&lt;/h1&gt;&lt;/header&gt; 需要注意的是，一个文档中可以包含一对或者一对以上的&lt;header&gt;标签。标签的位置是次要的，不一定非要显示在页面的上方，我们可以为任何需要的区块标签添加&lt;header&gt;元素，例如下面将要讲解的&lt;article&gt; &lt;section&gt;等标签。 （二）nav 表示页面的导航，可以通过导航连接到网站的其他页面，或者当前页面的其它部分。 &lt;nav&gt;不但可以作为页面独立的导航区域存在，我们还可以在&lt;header&gt;标签中使用。此外，&lt;nav&gt;标签还可以显示在侧边栏中。由此可见，一个页面之中可以有多个&lt;nav&gt;标签。 根据HTML5标准，&lt;nav&gt;标签只用于页面的主要导航部分。因为搜索引擎或者屏幕阅读器会根据&lt;nav&gt;标签来确定网站的主体内容，所以并不是任意一组超链接都适合放置在&lt;nav&gt;标签中,我们只要将主要的，基本的链接组放进&lt;nav&gt;即可,对于有辅助性的页脚链接则不推荐使用&lt;nav&gt;标签。 示例如下： 1234567891011&lt;header&gt; &lt;img src=&quot;images/logo.png&quot; alt=&quot;**科技&quot; /&gt; &lt;h1&gt;**信息科技有限公司&lt;/h1&gt; &lt;nav&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;example.html&quot;&gt;客户案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;service_one.html&quot;&gt;技术服务&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;aboutus_one.html&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;connection.html&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt; &lt;/nav&gt;&lt;/header&gt; 值得我们注意的是,HTML5规范不允许将&lt;nav&gt;标签嵌套在&lt;address&gt;标签中使用。 （三）aside 所包含的内容不是页面的主要内容、具有独立性，是对页面的补充。 &lt;aside&gt;标签一般使用在页面、文章的侧边栏、广告、友情链接等区域 示例如下： 12345678 &lt;article&gt; &lt;h1&gt;HTML5学习之语义化标签&lt;/h1&gt; &lt;p&gt;....正文.....&lt;/p&gt; &lt;aside&gt; &lt;h2&gt;什么是语义化标签&lt;/h2&gt; &lt;p&gt;语义化标签就是......&lt;/p&gt; &lt;/aside&gt;&lt;/article&gt; (四）footer 一般被放置在页面或者页面中某个区块的底部，包含版权信息、联系方式等信息。 跟&lt;header&gt;标签一样，&lt;footer&gt;标签的使用个数没有限制，可以在任意需要的区块底部使用。 示例如下： 12345&lt;footer&gt; &lt;small&gt; 版权所有 © 2016-2017 **信息科技有限公司 &lt;/small&gt;&lt;/footer&gt; （五）article 表示包含于一个文档、页面、应用程序或网站中的一段独立的内容，可以被独立的发布或者重新使用文章标记标签。 &lt;article&gt;标签应该使用在相对比较独立、完整的的内容区块，所以我们可以在一篇博客、一个论坛帖子、一篇新闻报道或者一个用户评论中使用它。通常情况下，一个&lt;article&gt;元素包括标题、正文和脚注。和&lt;nav&gt;标签一样，该标签同样不能用在&lt;address&gt;标签中； 示例如下： 12345&lt;article&gt; &lt;h1&gt;HTML5学习之语义化标签&lt;/h1&gt; &lt;p&gt;....正文.....&lt;/p&gt; &lt;footer&gt;版权所有*伪版必究&lt;/footer&gt;&lt;/article&gt; &lt;article&gt;标签还可以嵌套使用，但是它们必须是部分与整体的关系。例如在一篇发表的博客中，我们可以对读者评论使用该标签。 示例如下： 1234567891011121314151617181920212223&lt;article&gt; &lt;h1&gt;HTML5学习之语义化标签&lt;/h1&gt; &lt;p&gt;....正文.....&lt;/p&gt; &lt;article&gt; &lt;header&gt; &lt;h2&gt;读者评论&lt;/h2&gt; &lt;/header&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;评论人：张三&lt;/h3&gt; &lt;p&gt;评论时间：&lt;time datetime=&quot;2017-02-15&quot;&gt;2017-02-15 11:45:23&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;张三到此一游&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;评论人：李四&lt;/h3&gt; &lt;p&gt;评论时间：&lt;time datetime=&quot;2017-02-09&quot;&gt;2017-02-09 14:20:15&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;李四到此一游&lt;/p&gt; &lt;/article&gt; &lt;/article&gt; &lt;/article&gt; (六）section 是一个主题性的内容分组，通常用于对页面进行分块或者对文章等进行分段 &lt;section&gt;标签所包裹的是有一组相似的主题的内容，可以用这个标签来实现文章的章节、标签式对话框中的各种标签页等类似的功能。 &lt;section&gt;通常包含一个头部&lt;header&gt;、可能还会包含一个尾部&lt;footer&gt;。 示例如下： 12345678910111213141516&lt;article&gt; &lt;h1&gt;JavaScript框架&lt;/h1&gt; &lt;p&gt;Javascript框架是指以Javascript语言为基础搭建的编程框架。&lt;/p&gt; &lt;section&gt; &lt;h2&gt;angular.Js&lt;h2&gt; &lt;p&gt;angular.Js是一款优秀的前端JS框架&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;Vue.js&lt;h2&gt; &lt;p&gt;Vue.js是用于构建交互式的Web界面的库&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;jQuery&lt;h2&gt; &lt;p&gt;jQuery是一个快速、简洁的JavaScript框架。&lt;/p&gt; &lt;/section&gt;&lt;/article&gt; 在这篇关于JS框架的文章中,所列举的三个框架都是文章主题构成的一部分，所以我们使用&lt;section&gt;标签对其进行分段。 我们不但可以在&lt;article&gt;标签中使用&lt;section&gt;标签，还可以在&lt;section&gt;标签中使用&lt;article&gt;标签。 示例如下： 12345678910111213141516&lt;section&gt; &lt;h1&gt;HTML5技术栈&lt;/h1&gt; &lt;p&gt;广义而言的HTML5包含HTML、CSS和JavaScript三个部分&lt;/p&gt; &lt;article&gt; &lt;h2&gt;HTML&lt;h2&gt; &lt;p&gt;内容&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;CSS&lt;h2&gt; &lt;p&gt;样式&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;JavaScript&lt;h2&gt; &lt;p&gt;行为&lt;/p&gt; &lt;/article&gt;&lt;/section&gt; 在这个例子中，&lt;section&gt;标签代表一段内容，在这段内容中，HTML、CSS、Javascript是三个完全独立的部分，因而我们为这三个不同的部分分别使用&lt;article&gt;标签。 &lt;div&gt; &lt;section&gt; &lt;article&gt;三者的比较： &lt;div&gt;：应用广泛，只要我们想为一个区域定义一个样式或者为其添加JS行为，就可以使用div标签 &lt;section&gt;：包含的内容是一个明确的主题，通常有标题区域 &lt;article&gt;:如果我们的页面中需要一个单独的模块来实现一个单独的功能，就用&lt;article&gt;，其他的时候都用&lt;section&gt;。 四、文档级别语义HTML5试图为每个元素加入一个特定的文档级别语义。 （一）ruby、rt、rpruby是一种排版注释系统，是位于横排基础文本上方的简短文字，主要针对东亚语言作出简单的读音注释。例如可以为中文或日文显示读音。ruby涉及的元素包括ruby、rt以及rp。首先使用ruby指定一个具体的表达式，然后使用rt提供说明。rt部分将显示在表达式上方。下面这个例子中，拼音将显示在文字的上方。 1234&lt;ruby&gt; 北&lt;rt&gt;bei&lt;/rt&gt; 京&lt;rt&gt;jing&lt;/rt&gt;&lt;/ruby&gt; 但是在不支持ruby的浏览器中需要使用rp对这两个区块进行视觉上的隔离。 12345678910&lt;ruby&gt; 北 &lt;rp&gt; &lt;rt&gt;bei&lt;/rt&gt; &lt;/rp&gt; 京 &lt;rp&gt; &lt;rt&gt;jing&lt;/rt&gt; &lt;/rp&gt;&lt;/ruby&gt; ####（二）time 为了将现在的常用的日期和时间语句用规范的、利于机器识别的格式进行表述，time元素提供了一个可选的时间和时区组件。 为了确保机器能够正确识别，我们可以使用datetime属性，其属性值可以被定义为时间、日期或者这两者的复合体。 1&lt;time datetime=&quot;2017-07-03&quot;&gt; 还可以使用pubdate为一个网页指定发布时间。 注意：在 HTML5中，true或false并非有效的属性值，当解释器发现存在布尔属性时，它将直接解释为true。如果需要将属性设为false，将这个属性去掉即可。 （三）markmark元素用于高亮标记一段文字。可以使用mark元素来标记出网页里被搜索的关键词或是用于高亮显示一段解释性的代码。（四）wbrwbr元素用于让浏览器为长单词增加可选择的破折号，以便自动拆行。在相当长的单词中插入一对wbr元素，可以让浏览器根据排版的需要决定是否将单词换行。破折号是否出现，以及出现的位置完全由排版决定。wbr只是允许自动拆行，但非强制拆行。（五）略微改变的元素在HTML4版本中的标签元素在HTML5中有了新的定义。使用b表示文档渲染为粗体，而i表示文档渲染为斜体。使用strong和em来强调一段重要的文本。cite用来为对参考文献的引用进行定义，比如书籍或杂志的标题。small不仅仅指的是小字体，它还同样为法律声明增添不具有重要性的旁注或小字。hr现在表达的是主体性的间断，不再仅仅是分割版面的一条水平线。 今天就到这吧朋友们，拜拜","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-01-12T10:59:59.836Z","updated":"2018-02-12T06:47:10.907Z","comments":true,"path":"2018/01/12/hello-world/","link":"","permalink":"http://songda1005.cn/2018/01/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}